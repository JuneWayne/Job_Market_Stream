<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Job Market Analytics Dashboard</title>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Chart.js for some visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Leaflet + MarkerCluster for map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #020617 100%);
            color: #f9fafb;
            padding: 1.5rem;
            min-height: 100vh;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #38bdf8, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h2 {
            font-size: 1.5rem;
            margin: 2rem 0 1rem 0;
            color: #e5e7eb;
        }

        .subtitle {
            color: #9ca3af;
            font-size: 0.95rem;
            margin-bottom: 1.5rem;
        }

        /* Grid Layouts */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.25rem;
            margin-bottom: 2rem;
        }

        .two-column-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.25rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 1024px) {
            .two-column-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Cards */
        .card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            padding: 1.25rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.1);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 25px 35px -5px rgba(0, 0, 0, 0.2);
            border-color: rgba(59, 130, 246, 0.3);
        }

        .card h3 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #f3f4f6;
        }

        .card small {
            color: #6b7280;
            display: block;
            margin-bottom: 1rem;
            font-size: 0.85rem;
        }

        /* Pulse Metrics Cards */
        .pulse-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .pulse-card {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(168, 85, 247, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 1rem;
            padding: 1.25rem;
            position: relative;
            overflow: hidden;
        }

        .pulse-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6, #a855f7);
        }

        .pulse-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #9ca3af;
            margin-bottom: 0.5rem;
        }

        .pulse-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: #f9fafb;
        }

        .pulse-change {
            font-size: 0.85rem;
            margin-top: 0.25rem;
        }

        .pulse-change.up {
            color: #22c55e;
        }

        .pulse-change.down {
            color: #ef4444;
        }

        .pulse-change.stable {
            color: #6b7280;
        }

        /* Charts */
        svg {
            width: 100%;
            overflow: visible;
        }

        .axis path,
        .axis line {
            stroke: #4b5563;
        }

        .axis text {
            fill: #9ca3af;
            font-size: 11px;
        }

        .line {
            fill: none;
            stroke-width: 2.5px;
        }

        /* Heatmap */
        .heatmap-container {
            position: relative;
        }

        .heatmap-legend {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1rem;
            font-size: 0.8rem;
        }

        .heatmap-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .heatmap-legend-box {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        /* Skills Network */
        #skills-network-svg {
            background: radial-gradient(circle at center, rgba(59, 130, 246, 0.05), transparent);
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            filter: brightness(1.3);
        }

        .node-label {
            font-size: 10px;
            fill: #e5e7eb;
            pointer-events: none;
        }

        .link {
            stroke: #4b5563;
            stroke-opacity: 0.3;
        }

        /* Trending Skills */
        .trending-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 0.75rem;
        }

        .trending-skill {
            background: rgba(31, 41, 55, 0.5);
            border-radius: 0.5rem;
            padding: 0.75rem;
            border: 1px solid rgba(75, 85, 99, 0.3);
        }

        .trending-skill-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: #f3f4f6;
            margin-bottom: 0.25rem;
        }

        .trending-skill-change {
            font-size: 0.75rem;
        }

        .trending-skill-change.growing {
            color: #22c55e;
        }

        .trending-skill-change.declining {
            color: #ef4444;
        }

        .trending-skill-change.stable {
            color: #6b7280;
        }

        /* Culture Keywords Cloud */
        .keywords-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 1rem;
        }

        .keyword-bubble {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(168, 85, 247, 0.2));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 999px;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            cursor: default;
        }

        .keyword-bubble:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(168, 85, 247, 0.3));
        }

        /* Map */
        #map {
            width: 100%;
            height: 450px;
            border-radius: 1rem;
            overflow: hidden;
        }

        /* Tooltips */
        .tooltip {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 0.5rem;
            padding: 0.75rem;
            font-size: 0.85rem;
            color: #f9fafb;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        /* Loading states */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            color: #6b7280;
        }

        .loading::after {
            content: '‚ü≥';
            font-size: 2rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Error messages */
        .error-msg {
            color: #ef4444;
            font-size: 0.9rem;
            padding: 1rem;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 0.5rem;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* Beeswarm styles */
        #beeswarm-svg {
            width: 100%;
            height: 450px;
            background: linear-gradient(to bottom, rgba(15, 23, 42, 0.5) 0%, rgba(15, 23, 42, 0.8) 100%);
            border-radius: 10px;
        }

        .segmented {
            display: inline-flex;
            background: rgba(31, 41, 55, 0.5);
            border-radius: 999px;
            padding: 3px;
            gap: 3px;
            flex-wrap: wrap;
        }

        .segmented button {
            border: 0;
            background: transparent;
            padding: 6px 12px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #e5e7eb;
            transition: all 0.3s ease;
        }

        .segmented button.active {
            background: linear-gradient(135deg, #3b82f6, #a855f7);
            color: white;
        }

        /* Map legend */
        #map-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 23, 42, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            font-size: 12px;
            color: #e5e7eb;
        }

        #map-legend h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #f9fafb;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .legend-circle {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .legend-circle.low {
            background: #4A90E2;
        }

        .legend-circle.medium {
            background: #F39C12;
        }

        .legend-circle.high {
            background: #27AE60;
        }

        .legend-circle.unknown {
            background: #7f8c8d;
        }

        /* Custom markers */
        .custom-marker {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            line-height: 32px;
            transition: transform 0.2s;
            user-select: none;
        }

        .custom-marker:hover {
            transform: translateY(-5px) scale(1.1);
            cursor: pointer;
        }

        .marker-low {
            background: #4A90E2;
        }

        .marker-medium {
            background: #F39C12;
        }

        .marker-high {
            background: #27AE60;
        }

        .marker-unknown {
            background: #7f8c8d;
        }

        .leaflet-div-icon,
        .leaflet-marker-icon {
            background: none !important;
            border: none !important;
        }

        .cluster-marker-icon .cluster-marker {
            width: 40px;
            height: 40px;
            line-height: 40px;
            border-radius: 50%;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            background: #27AE60;
        }

        /* Popup styles */
        .leaflet-popup-content {
            max-width: 400px !important;
            color: #1f2937;
        }

        .leaflet-popup-content-wrapper {
            border-radius: 12px;
        }

        .jobs-scroll {
            max-height: 350px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .job-card {
            text-align: left;
            margin-bottom: 12px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .job-card:hover {
            background: #f1f5f9;
        }

        .job-card.highlight {
            outline: 2px solid #4A90E2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.25);
        }

        .job-card strong a {
            color: #3b82f6;
            text-decoration: none;
        }

        .job-card strong a:hover {
            text-decoration: underline;
        }

        /* Beeswarm chips */
        #bs-chips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
            max-height: 80px;
            overflow-y: auto;
        }

        .chip {
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 11px;
            cursor: pointer;
            background: rgba(31, 41, 55, 0.5);
            color: #e5e7eb;
            user-select: none;
            transition: all 0.2s;
        }

        .chip:hover {
            background: rgba(59, 130, 246, 0.2);
        }

        .chip.active {
            background: linear-gradient(135deg, #3b82f6, #a855f7);
            color: #fff;
            border-color: transparent;
        }

        /* Beeswarm tooltip */
        .bs-tip {
            position: fixed;
            pointer-events: none;
            z-index: 1300;
            background: rgba(15, 23, 42, 0.95);
            color: #f9fafb;
            font-size: 12px;
            padding: 8px 10px;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.15s ease;
            max-width: 320px;
            line-height: 1.4;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .group-label {
            font-size: 11px;
            fill: #9ca3af;
            paint-order: stroke;
            stroke: rgba(15, 23, 42, 0.8);
            stroke-width: 4px;
        }

        .leaflet-marker-icon.dim {
            filter: grayscale(1) opacity(0.25);
        }

        /* Map container relative for legend positioning */
        .map-container {
            position: relative;
        }
    </style>
</head>

<body>
    <h1>üìä Job Market Analytics Dashboard</h1>
    <div class="subtitle">
        Real-time insights powered by advanced analytics ‚Ä¢ Updated every 3 minutes
    </div>

    <!-- Pulse Metrics (Real-time KPIs) -->
    <div class="pulse-grid" id="pulse-metrics">
        <div class="pulse-card">
            <div class="pulse-label">Last Hour</div>
            <div class="pulse-value" id="pulse-last-hour">--</div>
            <div class="pulse-change" id="pulse-hour-change">Loading...</div>
        </div>
        <div class="pulse-card">
            <div class="pulse-label">Last 24 Hours</div>
            <div class="pulse-value" id="pulse-24h">--</div>
            <div class="pulse-change" id="pulse-24h-location">Loading...</div>
        </div>
        <div class="pulse-card">
            <div class="pulse-label">Hottest Function</div>
            <div class="pulse-value" id="pulse-function" style="font-size: 1.2rem;">--</div>
            <div class="pulse-change" id="pulse-avg-applicants">Loading...</div>
        </div>
        <div class="pulse-card">
            <div class="pulse-label">Trending Skill</div>
            <div class="pulse-value" id="pulse-skill" style="font-size: 1.2rem;">--</div>
            <div class="pulse-change">Most mentioned today</div>
        </div>
    </div>

    <!-- Competition Heatmap -->
    <div class="card">
        <h3>üî• Competition Heatmap - Best Times to Apply</h3>
        <small>Darker green = fewer applicants (better chance). Darker red = more competition.</small>
        <div id="competition-heatmap"></div>
        <div class="heatmap-legend" id="heatmap-legend"></div>
    </div>

    <!-- Two Column Layout for Historical vs Recent -->
    <div class="two-column-grid">
        <!-- Historical Trends -->
        <div>
            <h2>üìà Historical Trends</h2>

            <div class="card">
                <h3>Daily Job Postings</h3>
                <small>180-day trend analysis</small>
                <div id="chart-daily"></div>
            </div>

            <div class="card">
                <h3>Remote Work Evolution</h3>
                <small>Work mode distribution over time</small>
                <canvas id="remote-evolution-chart"></canvas>
            </div>

            <div class="card">
                <h3>Job Function Distribution</h3>
                <small>All-time breakdown by function</small>
                <div id="chart-func-all"></div>
            </div>
        </div>

        <!-- Recent Activity -->
        <div>
            <h2>‚ö° Recent Activity</h2>

            <div class="card">
                <h3>Company Hiring Velocity</h3>
                <small>Top companies ramping up (last 30 days)</small>
                <canvas id="company-velocity-chart"></canvas>
            </div>

            <div class="card">
                <h3>Job Lifecycle Funnel</h3>
                <small>How long jobs stay active</small>
                <canvas id="lifecycle-chart"></canvas>
            </div>

            <div class="card">
                <h3>Last 24 Hours Activity</h3>
                <small>Hourly job posting bubbles</small>
                <div id="chart-24h-bubbles" style="position: relative;"></div>
            </div>
        </div>
    </div>

    <!-- Skills Section -->
    <h2>üéØ Skills Intelligence</h2>

    <div class="two-column-grid">
        <!-- Skills Network Graph -->
        <div class="card">
            <h3>Skills Network</h3>
            <small>Click nodes to explore skill relationships</small>
            <svg id="skills-network-svg" height="400"></svg>
        </div>

        <!-- Trending Skills -->
        <div class="card">
            <h3>Trending Skills</h3>
            <small>Biggest movers in the last 30 days</small>
            <div class="trending-grid" id="trending-skills"></div>
        </div>
    </div>

    <!-- Culture Keywords -->
    <div class="card">
        <h3>üíº Company Culture Keywords</h3>
        <small>Most mentioned culture terms in job descriptions</small>
        <div class="keywords-cloud" id="culture-keywords"></div>
    </div>

    <!-- Map and Beeswarm -->
    <h2>üó∫Ô∏è Geographic Distribution & Job Explorer</h2>

    <div class="two-column-grid">
        <div class="card">
            <h3>Job Locations Map</h3>
            <small>Click markers for job details ‚Ä¢ Colors show applicant levels</small>
            <div class="map-container">
                <div id="map"></div>
                <div id="map-legend">
                    <h4>Avg Applicants</h4>
                    <div class="legend-item"><span class="legend-circle low"></span> Low (1‚Äì60)</div>
                    <div class="legend-item"><span class="legend-circle medium"></span> Medium (61‚Äì100)</div>
                    <div class="legend-item"><span class="legend-circle high"></span> High (101+)</div>
                    <div class="legend-item"><span class="legend-circle unknown"></span> Unknown</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>Interactive Job Explorer</h3>
            <small>Click dots to navigate to job on map ‚Ä¢ Filter by category</small>
            <div class="segmented" id="dimension-selector">
                <button data-dim="jobFunction" class="active">Function</button>
                <button data-dim="industry">Industry</button>
                <button data-dim="companies">Companies</button>
                <button data-dim="time">Time</button>
                <button data-dim="skills">Skills</button>
                <button data-dim="degree">Degree</button>
            </div>
            <div id="bs-chips"></div>
            <svg id="beeswarm-svg"></svg>
        </div>
    </div>

    <!-- Beeswarm Tooltip -->
    <div class="bs-tip" id="bs-tip"></div>

    <script>
        // API Endpoints
        const ANALYTICS_API = "https://job-market-stream.onrender.com";
        const JOBS_API = "https://jobdata-cih4.onrender.com";

        // Global variables
        let mapInstance = null;

        // ==================== PULSE METRICS ====================
        async function loadPulseMetrics() {
            try {
                const response = await fetch(`${ANALYTICS_API}/api/pulse_metrics`);
                const data = await response.json();

                // Update last hour
                document.getElementById('pulse-last-hour').textContent = data.last_hour.job_count;
                const hourChange = document.getElementById('pulse-hour-change');
                hourChange.textContent = `${data.last_hour.vs_weekly_avg > 0 ? '‚Üë' : '‚Üì'} ${Math.abs(data.last_hour.vs_weekly_avg)}% vs avg`;
                hourChange.className = `pulse-change ${data.last_hour.trend}`;

                // Update 24h stats
                document.getElementById('pulse-24h').textContent = data.last_24h.job_count;
                document.getElementById('pulse-24h-location').textContent = `üìç ${data.last_24h.hottest_location}`;

                // Update function and applicants
                document.getElementById('pulse-function').textContent = data.last_24h.hottest_function;
                document.getElementById('pulse-avg-applicants').textContent = `Avg ${data.last_24h.avg_applicants} applicants`;

                // Fetch trending skill separately
                const skillsRes = await fetch(`${ANALYTICS_API}/api/trending_skills?days_back=7&top_n=1`);
                const skills = await skillsRes.json();
                if (skills && skills.length > 0) {
                    document.getElementById('pulse-skill').textContent = skills[0].skill;
                }
            } catch (error) {
                console.error('Error loading pulse metrics:', error);
            }
        }

        // ==================== COMPETITION HEATMAP ====================
        async function loadCompetitionHeatmap() {
            try {
                const response = await fetch(`${ANALYTICS_API}/api/competition_heatmap`);
                const data = await response.json();

                const container = d3.select("#competition-heatmap");
                container.selectAll("*").remove();

                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const hours = d3.range(24);

                const margin = { top: 50, right: 30, bottom: 50, left: 60 };
                const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = 250;

                const svg = container.append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Scales
                const x = d3.scaleBand()
                    .domain(hours)
                    .range([0, width])
                    .padding(0.02);

                const y = d3.scaleBand()
                    .domain(days)
                    .range([0, height])
                    .padding(0.02);

                // Color scale - green (low competition) to red (high)
                const maxApplicants = d3.max(data, d => d.avg_applicants);
                const colorScale = d3.scaleSequential()
                    .interpolator(d3.interpolateRdYlGn)
                    .domain([maxApplicants, 0]); // Reversed for green = good

                // Create tooltip
                const tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0);

                // Draw cells
                g.selectAll(".hour")
                    .data(data)
                    .enter().append("rect")
                    .attr("x", d => x(d.hour))
                    .attr("y", d => y(days[d.day_of_week]))
                    .attr("width", x.bandwidth())
                    .attr("height", y.bandwidth())
                    .attr("fill", d => colorScale(d.avg_applicants))
                    .attr("stroke", "rgba(255,255,255,0.1)")
                    .style("cursor", "pointer")
                    .on("mouseover", function (event, d) {
                        tooltip.transition().duration(200).style("opacity", .9);
                        tooltip.html(`
                            <strong>${days[d.day_of_week]} ${d.hour}:00</strong><br/>
                            Avg applicants: ${Math.round(d.avg_applicants)}<br/>
                            Jobs posted: ${d.job_count}
                        `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");

                        d3.select(this).attr("stroke", "#fff").attr("stroke-width", 2);
                    })
                    .on("mouseout", function (d) {
                        tooltip.transition().duration(500).style("opacity", 0);
                        d3.select(this).attr("stroke", "rgba(255,255,255,0.1)").attr("stroke-width", 1);
                    });

                // Add axes
                g.append("g")
                    .selectAll("text")
                    .data(days)
                    .enter().append("text")
                    .text(d => d)
                    .attr("x", -10)
                    .attr("y", (d, i) => y(d) + y.bandwidth() / 2)
                    .style("text-anchor", "end")
                    .attr("alignment-baseline", "middle")
                    .style("font-size", "12px")
                    .style("fill", "#9ca3af");

                g.append("g")
                    .selectAll("text")
                    .data(hours)
                    .enter().append("text")
                    .text(d => d % 2 === 0 ? `${d}:00` : '')
                    .attr("x", d => x(d) + x.bandwidth() / 2)
                    .attr("y", height + 20)
                    .style("text-anchor", "middle")
                    .style("font-size", "10px")
                    .style("fill", "#9ca3af");

                // Add title
                svg.append("text")
                    .attr("x", width / 2 + margin.left)
                    .attr("y", 20)
                    .style("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("fill", "#e5e7eb")
                    .text("Average Competition by Day and Hour");

                // Update legend
                const legend = d3.select("#heatmap-legend");
                legend.selectAll("*").remove();

                const legendData = [
                    { label: "Low Competition", color: colorScale(0) },
                    { label: "Medium", color: colorScale(maxApplicants / 2) },
                    { label: "High Competition", color: colorScale(maxApplicants) }
                ];

                legendData.forEach(item => {
                    const div = legend.append("div").attr("class", "heatmap-legend-item");
                    div.append("div")
                        .attr("class", "heatmap-legend-box")
                        .style("background", item.color);
                    div.append("span").text(item.label);
                });

            } catch (error) {
                console.error('Error loading competition heatmap:', error);
                d3.select("#competition-heatmap").append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load competition heatmap");
            }
        }

        // ==================== SKILLS NETWORK ====================
        async function loadSkillsNetwork() {
            try {
                const response = await fetch(`${ANALYTICS_API}/api/skills_network?limit=30`);
                const data = await response.json();

                const svg = d3.select("#skills-network-svg");
                svg.selectAll("*").remove();

                const width = svg.node().getBoundingClientRect().width;
                const height = 400;

                svg.attr("width", width).attr("height", height);

                // Create force simulation
                const simulation = d3.forceSimulation(data.nodes)
                    .force("link", d3.forceLink(data.edges).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(d => Math.sqrt(d.size) * 2));

                // Draw links (if any)
                const link = svg.append("g")
                    .selectAll("line")
                    .data(data.edges || [])
                    .enter().append("line")
                    .attr("class", "link")
                    .attr("stroke-width", d => Math.sqrt(d.weight || 1));

                // Draw nodes
                const node = svg.append("g")
                    .selectAll("circle")
                    .data(data.nodes)
                    .enter().append("circle")
                    .attr("class", "node")
                    .attr("r", d => Math.sqrt(d.size) * 2)
                    .attr("fill", d => {
                        const scale = d3.scaleSequential(d3.interpolateViridis)
                            .domain([0, d3.max(data.nodes, n => n.size)]);
                        return scale(d.size);
                    })
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended));

                // Add labels
                const label = svg.append("g")
                    .selectAll("text")
                    .data(data.nodes)
                    .enter().append("text")
                    .attr("class", "node-label")
                    .text(d => d.label)
                    .style("font-size", d => Math.min(12, Math.sqrt(d.size)))
                    .attr("text-anchor", "middle");

                // Add tooltips
                node.append("title")
                    .text(d => `${d.label}: ${d.size} mentions`);

                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    label
                        .attr("x", d => d.x)
                        .attr("y", d => d.y);
                });

                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }

                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }

                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }

            } catch (error) {
                console.error('Error loading skills network:', error);
            }
        }

        // ==================== TRENDING SKILLS ====================
        async function loadTrendingSkills() {
            try {
                const response = await fetch(`${ANALYTICS_API}/api/trending_skills?days_back=30&top_n=12`);
                const data = await response.json();

                const container = d3.select("#trending-skills");
                container.selectAll("*").remove();

                data.forEach(skill => {
                    const div = container.append("div").attr("class", "trending-skill");

                    div.append("div")
                        .attr("class", "trending-skill-name")
                        .text(skill.skill);

                    const changeClass = skill.trend === 'growing' ? 'growing' :
                        skill.trend === 'declining' ? 'declining' : 'stable';

                    const arrow = skill.trend === 'growing' ? '‚Üë' :
                        skill.trend === 'declining' ? '‚Üì' : '‚Üí';

                    div.append("div")
                        .attr("class", `trending-skill-change ${changeClass}`)
                        .text(`${arrow} ${Math.abs(Math.round(skill.change_percent))}%`);

                    div.append("div")
                        .style("font-size", "0.7rem")
                        .style("color", "#6b7280")
                        .text(`${skill.recent_mentions} mentions`);
                });

            } catch (error) {
                console.error('Error loading trending skills:', error);
            }
        }

        // ==================== CULTURE KEYWORDS ====================
        async function loadCultureKeywords() {
            try {
                const response = await fetch(`${ANALYTICS_API}/api/culture_keywords?limit=20`);
                const data = await response.json();

                const container = d3.select("#culture-keywords");
                container.selectAll("*").remove();

                // Size scale based on count
                const maxCount = d3.max(data, d => d.count);
                const sizeScale = d3.scaleLinear()
                    .domain([0, maxCount])
                    .range([0.8, 1.5]);

                data.forEach(keyword => {
                    container.append("div")
                        .attr("class", "keyword-bubble")
                        .style("font-size", `${sizeScale(keyword.count)}rem`)
                        .style("opacity", 0.6 + (keyword.count / maxCount) * 0.4)
                        .text(`${keyword.keyword} (${keyword.percentage.toFixed(1)}%)`);
                });

            } catch (error) {
                console.error('Error loading culture keywords:', error);
            }
        }

        // ==================== COMPANY VELOCITY CHART ====================
        async function loadCompanyVelocity() {
            try {
                const response = await fetch(`${ANALYTICS_API}/api/company_velocity?days=30&top_n=10`);
                const data = await response.json();

                // Group by company
                const companies = d3.group(data, d => d.company_name);

                // Prepare data for Chart.js
                const labels = [...new Set(data.map(d => d.day))].sort();
                const datasets = [];

                const colors = d3.schemeCategory10;
                let colorIndex = 0;

                companies.forEach((values, company) => {
                    datasets.push({
                        label: company,
                        data: labels.map(day => {
                            const dayData = values.find(v => v.day === day);
                            return dayData ? dayData.cumulative_posts : 0;
                        }),
                        borderColor: colors[colorIndex % colors.length],
                        backgroundColor: colors[colorIndex % colors.length] + '33',
                        tension: 0.4
                    });
                    colorIndex++;
                });

                // Create chart
                const ctx = document.getElementById('company-velocity-chart').getContext('2d');
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels.map(d => new Date(d).toLocaleDateString()),
                        datasets: datasets.slice(0, 5) // Limit to top 5 for clarity
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: { color: '#9ca3af' }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: '#374151' },
                                ticks: { color: '#9ca3af' }
                            },
                            x: {
                                grid: { color: '#374151' },
                                ticks: { color: '#9ca3af', maxRotation: 45 }
                            }
                        }
                    }
                });

            } catch (error) {
                console.error('Error loading company velocity:', error);
            }
        }

        // ==================== JOB LIFECYCLE FUNNEL ====================
        async function loadJobLifecycle() {
            try {
                const response = await fetch(`${ANALYTICS_API}/api/job_lifecycle`);
                const data = await response.json();

                const ctx = document.getElementById('lifecycle-chart').getContext('2d');
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.map(d => d.lifecycle_stage),
                        datasets: [{
                            label: 'Job Count',
                            data: data.map(d => d.job_count),
                            backgroundColor: data.map((d, i) => {
                                const colors = ['#22c55e', '#3b82f6', '#a855f7', '#f59e0b', '#ef4444', '#6b7280'];
                                return colors[i % colors.length];
                            })
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                grid: { color: '#374151' },
                                ticks: { color: '#9ca3af' }
                            },
                            y: {
                                grid: { color: '#374151' },
                                ticks: { color: '#9ca3af' }
                            }
                        }
                    }
                });

            } catch (error) {
                console.error('Error loading job lifecycle:', error);
            }
        }

        // ==================== REMOTE EVOLUTION CHART ====================
        async function loadRemoteEvolution() {
            try {
                const response = await fetch(`${ANALYTICS_API}/api/remote_evolution?days=180`);
                const data = await response.json();

                // Group by week and work mode
                const weeks = [...new Set(data.map(d => d.week))].sort();
                const workModes = [...new Set(data.map(d => d.work_mode))];

                const datasets = workModes.map(mode => {
                    const color = mode.includes('Remote') ? '#22c55e' :
                        mode.includes('Hybrid') ? '#3b82f6' :
                            mode.includes('On-site') ? '#ef4444' : '#6b7280';

                    return {
                        label: mode,
                        data: weeks.map(week => {
                            const weekData = data.find(d => d.week === week && d.work_mode === mode);
                            return weekData ? weekData.percentage : 0;
                        }),
                        backgroundColor: color + '88',
                        borderColor: color,
                        fill: true
                    };
                });

                const ctx = document.getElementById('remote-evolution-chart').getContext('2d');
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: weeks.map(w => new Date(w).toLocaleDateString()),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: { color: '#9ca3af' }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '%';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                stacked: true,
                                grid: { color: '#374151' },
                                ticks: {
                                    color: '#9ca3af',
                                    callback: function (value) {
                                        return value + '%';
                                    }
                                }
                            },
                            x: {
                                grid: { color: '#374151' },
                                ticks: { color: '#9ca3af', maxRotation: 45 }
                            }
                        }
                    }
                });

            } catch (error) {
                console.error('Error loading remote evolution:', error);
            }
        }

        // ==================== EXISTING FUNCTIONS (Daily chart, etc.) ====================
        async function loadDailyCounts() {
            try {
                const res = await fetch(`${ANALYTICS_API}/api/daily_counts?days=180`);
                const data = await res.json();

                const container = d3.select("#chart-daily");
                container.selectAll("*").remove();

                if (!data || data.length === 0) {
                    container.append("div").attr("class", "error-msg").text("No data available");
                    return;
                }

                data.forEach(d => {
                    d.date = new Date(d.day);
                    d.job_count = +d.job_count;
                });

                const margin = { top: 20, right: 20, bottom: 35, left: 45 };
                const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = 260 - margin.top - margin.bottom;

                const svg = container.append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleUtc()
                    .domain(d3.extent(data, d => d.date))
                    .range([0, width]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.job_count)])
                    .nice()
                    .range([height, 0]);

                // Add gradient
                const gradient = svg.append("defs")
                    .append("linearGradient")
                    .attr("id", "line-gradient")
                    .attr("gradientUnits", "userSpaceOnUse")
                    .attr("x1", 0).attr("y1", y(0))
                    .attr("x2", 0).attr("y2", y(d3.max(data, d => d.job_count)));

                gradient.append("stop")
                    .attr("offset", "0%")
                    .attr("stop-color", "#3b82f6")
                    .attr("stop-opacity", 0.1);

                gradient.append("stop")
                    .attr("offset", "100%")
                    .attr("stop-color", "#3b82f6")
                    .attr("stop-opacity", 0.8);

                // Area
                const area = d3.area()
                    .x(d => x(d.date))
                    .y0(height)
                    .y1(d => y(d.job_count))
                    .curve(d3.curveMonotoneX);

                g.append("path")
                    .datum(data)
                    .attr("fill", "url(#line-gradient)")
                    .attr("d", area);

                // Line
                const line = d3.line()
                    .x(d => x(d.date))
                    .y(d => y(d.job_count))
                    .curve(d3.curveMonotoneX);

                g.append("path")
                    .datum(data)
                    .attr("fill", "none")
                    .attr("stroke", "#3b82f6")
                    .attr("stroke-width", 2.5)
                    .attr("d", line);

                // Axes
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(6).tickFormat(d3.timeFormat("%b %d")));

                g.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(y).ticks(5));

            } catch (error) {
                console.error('Error loading daily counts:', error);
            }
        }

        // ==================== 24H BUBBLES ====================
        async function loadHourlyCounts() {
            try {
                const res = await fetch(`${ANALYTICS_API}/api/hourly_counts?hours=24`);
                const data = await res.json();

                const container = d3.select("#chart-24h-bubbles");
                container.selectAll("*").remove();

                if (!data || data.length === 0) {
                    container.append("div").attr("class", "error-msg").text("No data for last 24 hours");
                    return;
                }

                data.forEach(d => {
                    d.date = new Date(d.hour);
                    d.job_count = +d.job_count;
                });

                const margin = { top: 20, right: 20, bottom: 35, left: 45 };
                const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = 260 - margin.top - margin.bottom;

                const svg = container.append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleTime()
                    .domain(d3.extent(data, d => d.date))
                    .range([0, width]);

                const maxCount = d3.max(data, d => d.job_count) || 1;

                const r = d3.scaleSqrt()
                    .domain([0, maxCount])
                    .range([5, 20]);

                const y = d3.scaleLinear()
                    .domain([0, maxCount])
                    .nice()
                    .range([height, 0]);

                const latestDate = d3.max(data, d => d.date);

                // Bubbles
                g.selectAll("circle")
                    .data(data)
                    .enter().append("circle")
                    .attr("cx", d => x(d.date))
                    .attr("cy", d => y(d.job_count))
                    .attr("r", d => r(d.job_count))
                    .attr("fill", d => d.date.getTime() === latestDate.getTime() ? "#22c55e" : "#3b82f6")
                    .attr("opacity", 0.7)
                    .append("title")
                    .text(d => `${d3.timeFormat("%b %d, %H:00")(d.date)}: ${d.job_count} jobs`);

                // Axes
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(6).tickFormat(d3.timeFormat("%H:%M")));

                g.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(y).ticks(4));

            } catch (error) {
                console.error('Error loading hourly counts:', error);
            }
        }

        // ==================== JOB FUNCTION CHART ====================
        async function loadJobsByFunction() {
            try {
                const res = await fetch(`${ANALYTICS_API}/api/jobs_by_function`);
                const data = await res.json();

                const container = d3.select("#chart-func-all");
                container.selectAll("*").remove();

                // Take top 10
                const topData = data.slice(0, 10);

                const margin = { top: 20, right: 20, bottom: 100, left: 60 };
                const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = 300 - margin.top - margin.bottom;

                const svg = container.append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleBand()
                    .domain(topData.map(d => d.job_function))
                    .range([0, width])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(topData, d => d.count)])
                    .nice()
                    .range([height, 0]);

                // Bars
                g.selectAll(".bar")
                    .data(topData)
                    .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d.job_function))
                    .attr("y", d => y(d.count))
                    .attr("width", x.bandwidth())
                    .attr("height", d => height - y(d.count))
                    .attr("fill", "#a855f7")
                    .attr("opacity", 0.8);

                // Axes
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");

                g.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(y));

            } catch (error) {
                console.error('Error loading job functions:', error);
            }
        }

        // ==================== BEESWARM & MAP (Enhanced) ====================
        // Global state for map-beeswarm interaction (mapInstance declared above)
        let clusters = null;
        let markersByKey = {};
        let coordsByKey = {};
        let beeswarmNodes = [];

        // Helper functions
        const slugify = str => (str || '').toString().toLowerCase().trim().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
        const clean = v => (v || 'Unknown').toString().trim();
        const firstToken = v => clean(v).split(',')[0].split('/')[0].trim() || 'Unknown';
        const toInt = x => { if (x == null) return null; const m = x.toString().match(/\d+/); return m ? +m[0] : null; };

        function degreeLevel(text = '') {
            const v = text.toLowerCase();
            if (/(ph\.?d|doctor|doctoral|dphil)/.test(v)) return 'PhD';
            if (/(master|m\.s\.|ms\b|m\.sc)/.test(v)) return "Master's";
            if (/(bachelor|b\.s\.|bs\b|ba\b|b\.a\.|bsc)/.test(v)) return "Bachelor's";
            if (/(associate|a\.s\.|aa\b)/.test(v)) return "Associate's";
            if (/high\s*school|ged/.test(v)) return 'High School';
            if (/(enrolled|pursuing|working toward|currently)/.test(v)) return 'Enrolled';
            return 'Other';
        }

        function bucketTime(str) {
            const v = (str || '').toLowerCase().trim();
            if (!v) return 'Unknown';
            if (v.includes('just') || v.includes('hour') || v.includes('hr')) return 'Last 24h';
            const m = v.match(/(\d+)\s*(day|week|month|hour|hr)/);
            if (m) {
                const n = +m[1], u = m[2];
                if (u.startsWith('hour') || u.startsWith('hr')) return 'Last 24h';
                if (u.startsWith('day')) return n <= 1 ? 'Last 24h' : (n <= 7 ? 'Past week' : (n <= 30 ? 'Past month' : 'Older'));
                if (u.startsWith('week')) return n <= 1 ? 'Past week' : (n <= 4 ? 'Past month' : 'Older');
                if (u.startsWith('month')) return n <= 1 ? 'Past month' : 'Older';
            }
            if (v.includes('30+')) return 'Older';
            return 'Unknown';
        }

        // Company grouping
        const COMPANY_GROUPS = {
            'Tech Giants': ['google', 'alphabet', 'meta', 'facebook', 'amazon', 'apple', 'microsoft', 'netflix', 'nvidia', 'adobe', 'salesforce', 'oracle', 'ibm', 'uber', 'airbnb', 'palantir', 'snowflake', 'databricks', 'stripe'],
            'Consulting': ['mckinsey', 'boston consulting', 'bcg', 'bain', 'deloitte', 'pwc', 'kpmg', 'ey', 'ernst young', 'accenture', 'booz allen'],
            'Finance': ['jpmorgan', 'goldman sachs', 'morgan stanley', 'bank of america', 'citigroup', 'wells fargo', 'blackrock', 'citadel', 'two sigma', 'capital one', 'american express'],
            'Healthcare': ['johnson', 'pfizer', 'merck', 'abbvie', 'amgen', 'novartis', 'roche', 'bristol myers', 'eli lilly'],
            'Retail': ['walmart', 'target', 'costco', 'ebay', 'wayfair', 'best buy', 'home depot']
        };
        const COMPANY_PRIORITY = Object.keys(COMPANY_GROUPS);

        function companyGroup(name = '') {
            const s = name.toLowerCase().replace(/[^\w\s]/g, ' ');
            for (const cat of COMPANY_PRIORITY) {
                for (const term of COMPANY_GROUPS[cat]) {
                    if (s.includes(term)) return cat;
                }
            }
            return 'Other';
        }

        // Extract skills from job
        function extractSkills(job) {
            const text = job.skills_desired || job.skills || '';
            if (!text) return [];
            return text.split(/[,;]/).map(s => s.trim()).filter(s => s.length > 1 && s.length < 30).slice(0, 10);
        }

        // Dimension configuration
        function buildDimensions(nodes) {
            function topK(arr, acc, k = 8) {
                const m = d3.rollup(arr, v => v.length, d => acc(d));
                return Array.from(m, ([name, count]) => ({ name, count }))
                    .sort((a, b) => d3.descending(a.count, b.count))
                    .slice(0, k).map(d => d.name);
            }

            const topFunctions = topK(nodes, d => d.jobFunction, 8);
            const topIndustries = topK(nodes, d => d.industry, 8);
            const topSkills = topK(nodes.flatMap(d => d.skills.map(s => ({ skill: s }))), d => d.skill, 12);
            const degreeGroups = ["Bachelor's", "Master's", 'PhD', "Associate's", 'Enrolled', 'High School', 'Other'];

            return {
                jobFunction: { label: 'Job Function', groups: [...topFunctions].sort(d3.ascending).concat('Other'), topSet: new Set(topFunctions) },
                industry: { label: 'Industry', groups: [...topIndustries].sort(d3.ascending).concat('Other'), topSet: new Set(topIndustries) },
                companies: { label: 'Companies', groups: [...COMPANY_PRIORITY, 'Other'] },
                time: { label: 'Time Posted', groups: ['Last 24h', 'Past week', 'Past month', 'Older', 'Unknown'] },
                degree: { label: 'Degree', groups: degreeGroups },
                skills: { label: 'Skills', groups: [...topSkills, 'Other'], topSet: new Set(topSkills) }
            };
        }

        function groupValue(dim, d, dims) {
            if (dim === 'jobFunction') return dims.jobFunction.topSet.has(d.jobFunction) ? d.jobFunction : 'Other';
            if (dim === 'industry') return dims.industry.topSet.has(d.industry) ? d.industry : 'Other';
            if (dim === 'companies') return d.companyBucket || 'Other';
            if (dim === 'time') return d.timeBucket;
            if (dim === 'degree') return dims.degree.groups.includes(d.degreeLevel) ? d.degreeLevel : 'Other';
            if (dim === 'skills') {
                const match = d.skills.find(s => dims.skills.topSet.has(s));
                return match || 'Other';
            }
            return 'Other';
        }

        // Load map and beeswarm together
        async function loadMapAndBeeswarm() {
            try {
                // Fetch all data
                const [jobsRes, summaryRes, geoRes] = await Promise.all([
                    fetch(`${JOBS_API}/api/jobs`),
                    fetch(`${JOBS_API}/api/job_summaries`).catch(() => ({ ok: false })),
                    fetch(`${JOBS_API}/api/geo_locations`)
                ]);

                const jobs = await jobsRes.json();
                const summary = summaryRes.ok ? await summaryRes.json() : [];
                const locations = geoRes.ok ? await geoRes.json() : [];

                // Build location metadata
                const jobData = {};
                jobs.forEach(job => {
                    const k = (job.location || 'Unknown').trim().toLowerCase();
                    (jobData[k] = jobData[k] || []).push(job);
                });

                const locationMeta = {};
                summary.forEach(s => {
                    const k = (s.location || 'Unknown').trim().toLowerCase();
                    locationMeta[k] = { jobCount: s.number_of_jobs, avgApplicants: s.average_applicants };
                });

                // Initialize map
                if (mapInstance) mapInstance.remove();
                mapInstance = L.map('map').setView([39.8283, -98.5795], 4);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap'
                }).addTo(mapInstance);

                // Create marker cluster group
                clusters = L.markerClusterGroup({
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: false,
                    maxClusterRadius: z => z < 5 ? 200 : z < 8 ? 100 : z < 12 ? 50 : 20,
                    iconCreateFunction: cluster => {
                        let sum = 0;
                        cluster.getAllChildMarkers().forEach(m => sum += (m.options.jobCount || 0));
                        return L.divIcon({
                            className: 'cluster-marker-icon',
                            html: `<div class="cluster-marker">${sum}</div>`,
                            iconSize: [40, 40],
                            iconAnchor: [20, 20]
                        });
                    }
                });

                // Add markers for each location
                markersByKey = {};
                coordsByKey = {};
                const seen = new Set();

                locations.forEach((loc, i) => {
                    const raw = loc.location || 'Unknown';
                    const key = raw.trim().toLowerCase();
                    if (seen.has(key)) return;
                    seen.add(key);

                    const { latitude: lat, longitude: lng } = loc;
                    if (!lat || !lng) return;

                    const meta = locationMeta[key] || { jobCount: 0, avgApplicants: 0 };
                    const jobsHere = jobData[key] || [];
                    const count = jobsHere.length;
                    const avg = meta.avgApplicants || 0;

                    // Determine applicant level
                    let level = 'unknown';
                    if (avg > 0 && avg < 61) level = 'low';
                    else if (avg >= 61 && avg < 101) level = 'medium';
                    else if (avg >= 101) level = 'high';

                    const icon = L.divIcon({
                        html: `<div class="custom-marker marker-${level}" title="${raw}: ${count} jobs">${count}</div>`,
                        iconSize: [32, 32],
                        iconAnchor: [16, 32]
                    });

                    const marker = L.marker([lat, lng], { icon, jobCount: count });

                    // Build popup with job cards
                    const listId = `jobs-list-${slugify(key)}`;
                    let popupHTML = `
                        <div class="popup-content">
                            <b style="font-size:16px;">${raw}</b><br>
                            <span style="color:#666;">${count} job${count !== 1 ? 's' : ''} ‚Ä¢ Avg applicants: ${Math.round(avg)}</span>
                            <hr style="margin:8px 0;">
                            <div id="${listId}" class="jobs-scroll">`;

                    jobsHere.forEach(job => {
                        const cardId = slugify(`${job.job_title} ${job.company_name || ''}`);
                        const jobLink = job.job_link && job.job_link !== 'N/A'
                            ? (/^https?:\/\//i.test(job.job_link) ? job.job_link : `https://${job.job_link}`)
                            : null;
                        const appLink = job.application_link && job.application_link !== 'N/A'
                            ? (/^https?:\/\//i.test(job.application_link) ? job.application_link : `https://${job.application_link}`)
                            : null;

                        popupHTML += `
                            <div id="${cardId}" class="job-card">
                                <strong style="font-size:14px;">
                                    ${jobLink ? `<a href="${jobLink}" target="_blank">${job.job_title || 'Untitled'}</a>` : (job.job_title || 'Untitled')}
                                </strong><br>
                                <div style="font-size:12px; color:#4b5563; margin-top:4px;">
                                    <b>Company:</b> ${job.company_name || 'N/A'}<br>
                                    <b>Posted:</b> ${job.time_posted || 'N/A'}<br>
                                    <b>Applicants:</b> ${job.num_applicants || 'N/A'}<br>
                                    <b>Function:</b> ${job['Job Function'] || 'N/A'}<br>
                                    <b>Industry:</b> ${job['Industries'] || 'N/A'}<br>
                                    ${job.skills_desired ? `<b>Skills:</b> ${job.skills_desired.slice(0, 100)}${job.skills_desired.length > 100 ? '...' : ''}<br>` : ''}
                                    ${job.degree_qualifications ? `<b>Degree:</b> ${job.degree_qualifications}<br>` : ''}
                                    ${job.summary ? `<b>Summary:</b> ${job.summary.slice(0, 150)}${job.summary.length > 150 ? '...' : ''}<br>` : ''}
                                    ${appLink ? `<b>Apply:</b> <a href="${appLink}" target="_blank">Link</a>` : ''}
                                </div>
                            </div>`;
                    });

                    popupHTML += `</div></div>`;
                    marker.bindPopup(popupHTML, { maxWidth: 400, maxHeight: 450 });
                    clusters.addLayer(marker);
                    markersByKey[key] = marker;
                    coordsByKey[key] = [lat, lng];
                });

                mapInstance.addLayer(clusters);

                // Build beeswarm nodes
                beeswarmNodes = jobs.map((j, i) => {
                    const locationKey = clean(j.location).toLowerCase();
                    const applicants = toInt(j.num_applicants);
                    return {
                        id: i,
                        title: clean(j.job_title),
                        company: clean(j.company_name),
                        locationRaw: clean(j.location),
                        locationKey,
                        locationSlug: slugify(locationKey),
                        jobSlug: slugify(`${j.job_title} ${j.company_name || ''}`),
                        coords: coordsByKey[locationKey] || null,
                        applicants,
                        appLevel: applicants == null ? 'unknown' : (applicants < 61 ? 'low' : (applicants < 101 ? 'medium' : 'high')),
                        jobFunction: firstToken(j['Job Function'] || j.job_function),
                        industry: firstToken(j['Industries'] || j.industry),
                        timeBucket: bucketTime(j.time_posted),
                        degreeLevel: degreeLevel(j.degree_qualifications || j.degree_requirement || ''),
                        skills: extractSkills(j),
                        companyBucket: companyGroup(j.company_name || ''),
                        jobLink: j.job_link && j.job_link !== 'N/A' ? j.job_link : null
                    };
                });

                // Initialize beeswarm
                initBeeswarm(beeswarmNodes);

            } catch (error) {
                console.error('Error loading map/beeswarm:', error);
                d3.select("#map").html('<div class="error-msg">Failed to load map data</div>');
            }
        }

        function initBeeswarm(nodes) {
            const svg = d3.select('#beeswarm-svg');
            svg.selectAll('*').remove();

            const tip = d3.select('#bs-tip');
            const container = svg.node().parentNode;
            const rect = container.getBoundingClientRect();

            const margin = { top: 20, right: 10, bottom: 20, left: 10 };
            const width = rect.width - margin.left - margin.right;
            const height = 400;

            svg.attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

            // Build dimensions
            const dims = buildDimensions(nodes);
            let currentDim = 'jobFunction';
            let activeChip = 'All';

            // Create centroids for grouping
            function makeCentroids(groups) {
                const n = groups.length;
                const cols = width >= 600 ? 3 : (width >= 400 ? 2 : 1);
                const rows = Math.ceil(n / cols);
                const xPad = 40, yPad = 40;
                const xs = d3.scalePoint().domain(d3.range(cols)).range([xPad, width - xPad]).padding(0.5);
                const ys = d3.scalePoint().domain(d3.range(rows)).range([yPad, height - yPad]).padding(0.5);
                const map = new Map();
                groups.forEach((name, i) => {
                    const c = i % cols, r = Math.floor(i / cols);
                    map.set(name, { x: xs(c), y: ys(r) });
                });
                return map;
            }

            let centroids = makeCentroids(dims[currentDim].groups);

            // Scales
            const rScale = d3.scaleSqrt()
                .domain([0, d3.max(nodes, d => d.applicants || 0) || 1])
                .range([3, 10]);

            const colorByApplicants = d =>
                d.appLevel === 'low' ? '#4A90E2' :
                    d.appLevel === 'medium' ? '#F39C12' :
                        d.appLevel === 'high' ? '#27AE60' : '#7f8c8d';

            // Draw circles
            const circles = g.append('g').attr('class', 'circles')
                .selectAll('circle')
                .data(nodes, d => d.id)
                .join('circle')
                .attr('r', d => rScale(d.applicants || 0))
                .attr('fill', colorByApplicants)
                .attr('stroke', 'rgba(255,255,255,0.3)')
                .attr('stroke-width', 0.5)
                .style('cursor', 'pointer')
                .on('mouseenter', function (event, d) {
                    d3.select(this).attr('stroke-width', 2).attr('stroke', '#fff');
                    tip.style('opacity', 1)
                        .html(`<b>${d.title}</b><br>${d.company} ‚Äî ${d.locationRaw}<br><i>${d.jobFunction} ‚Ä¢ ${d.timeBucket}${d.skills.length ? ' ‚Ä¢ ' + d.skills.slice(0, 3).join(', ') : ''}</i>`);
                })
                .on('mousemove', function (event) {
                    tip.style('left', (event.clientX + 12) + 'px')
                        .style('top', (event.clientY + 12) + 'px');
                })
                .on('mouseleave', function () {
                    d3.select(this).attr('stroke-width', 0.5).attr('stroke', 'rgba(255,255,255,0.3)');
                    tip.style('opacity', 0);
                })
                .on('click', (event, d) => {
                    if (!d.coords) return;
                    const mk = markersByKey[d.locationKey];
                    if (!mk) return;

                    clusters.zoomToShowLayer(mk, () => {
                        mapInstance.once('popupopen', () => {
                            const listEl = document.getElementById(`jobs-list-${d.locationSlug}`);
                            const target = listEl && document.getElementById(d.jobSlug);
                            if (target) {
                                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                target.classList.add('highlight');
                                setTimeout(() => target.classList.remove('highlight'), 1500);
                            }
                        });
                        mk.openPopup();
                    });
                });

            // Group labels
            const labelLayer = g.append('g').attr('class', 'group-labels');

            function renderGroupLabels() {
                const groups = dims[currentDim].groups;
                labelLayer.selectAll('*').remove();
                groups.forEach(name => {
                    const c = centroids.get(name);
                    if (c) {
                        labelLayer.append('text')
                            .attr('class', 'group-label')
                            .attr('x', c.x)
                            .attr('y', c.y - 30)
                            .attr('text-anchor', 'middle')
                            .text(name);
                    }
                });
            }

            // Force simulation
            const sim = d3.forceSimulation(nodes)
                .alpha(1)
                .velocityDecay(0.3)
                .force('x', d3.forceX(d => centroids.get(groupValue(currentDim, d, dims))?.x || width / 2).strength(0.12))
                .force('y', d3.forceY(d => centroids.get(groupValue(currentDim, d, dims))?.y || height / 2).strength(0.12))
                .force('collide', d3.forceCollide(d => rScale(d.applicants || 0) + 1.5))
                .on('tick', () => {
                    circles
                        .attr('cx', d => d.x = Math.max(8, Math.min(width - 8, d.x || width / 2)))
                        .attr('cy', d => d.y = Math.max(8, Math.min(height - 8, d.y || height / 2)));
                });

            renderGroupLabels();

            // Chips for filtering
            const chipsWrap = d3.select('#bs-chips');

            function renderChips() {
                const cats = ['All', ...dims[currentDim].groups];
                chipsWrap.selectAll('*').remove();
                cats.forEach(val => {
                    chipsWrap.append('div')
                        .attr('class', `chip${val === activeChip ? ' active' : ''}`)
                        .text(val)
                        .on('click', () => {
                            activeChip = val;
                            chipsWrap.selectAll('.chip').classed('active', function () {
                                return d3.select(this).text() === val;
                            });
                            applyFilter();
                        });
                });
            }

            function applyFilter() {
                circles.transition().duration(200)
                    .style('opacity', d => (activeChip === 'All' || groupValue(currentDim, d, dims) === activeChip) ? 1 : 0.1);

                // Dim map markers
                const allowKeys = new Set(
                    activeChip === 'All'
                        ? nodes.map(n => n.locationKey)
                        : nodes.filter(n => groupValue(currentDim, n, dims) === activeChip).map(n => n.locationKey)
                );
                Object.entries(markersByKey).forEach(([k, mk]) => {
                    const el = mk.getElement && mk.getElement();
                    if (!el) return;
                    if (allowKeys.has(k)) el.classList.remove('dim');
                    else el.classList.add('dim');
                });
            }

            renderChips();
            applyFilter();

            // Dimension selector
            d3.selectAll('#dimension-selector button').on('click', function () {
                const dim = this.getAttribute('data-dim');
                if (dim === currentDim) return;

                d3.selectAll('#dimension-selector button').classed('active', false);
                d3.select(this).classed('active', true);

                currentDim = dim;
                centroids = makeCentroids(dims[currentDim].groups);
                renderGroupLabels();
                activeChip = 'All';
                renderChips();

                sim.force('x', d3.forceX(d => centroids.get(groupValue(currentDim, d, dims))?.x || width / 2).strength(0.12));
                sim.force('y', d3.forceY(d => centroids.get(groupValue(currentDim, d, dims))?.y || height / 2).strength(0.12));
                sim.alpha(0.8).restart();
                applyFilter();
            });

            // Handle resize
            window.addEventListener('resize', () => {
                const newRect = container.getBoundingClientRect();
                const newWidth = newRect.width - margin.left - margin.right;
                svg.attr('width', newWidth + margin.left + margin.right);
                centroids = makeCentroids(dims[currentDim].groups);
                renderGroupLabels();
                sim.force('x', d3.forceX(d => centroids.get(groupValue(currentDim, d, dims))?.x || newWidth / 2).strength(0.12));
                sim.alpha(0.3).restart();
            });
        }

        // Legacy function names for compatibility
        async function loadBeeswarm() {
            // Combined with loadMap
        }

        async function loadMap() {
            await loadMapAndBeeswarm();
        }

        // ==================== INITIALIZE DASHBOARD ====================
        async function initDashboard() {
            // Show loading states
            document.querySelectorAll('.card').forEach(card => {
                if (!card.querySelector('.loading')) {
                    const loading = document.createElement('div');
                    loading.className = 'loading';
                    loading.textContent = 'Loading...';
                    card.appendChild(loading);
                }
            });

            // Load all visualizations
            await Promise.all([
                loadPulseMetrics(),
                loadCompetitionHeatmap(),
                loadSkillsNetwork(),
                loadTrendingSkills(),
                loadCultureKeywords(),
                loadCompanyVelocity(),
                loadJobLifecycle(),
                loadRemoteEvolution(),
                loadDailyCounts(),
                loadHourlyCounts(),
                loadJobsByFunction(),
                loadBeeswarm(),
                loadMap()
            ]);

            // Remove loading states
            document.querySelectorAll('.loading').forEach(el => el.remove());
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', initDashboard);

        // Auto-refresh every 3 minutes
        setInterval(() => {
            loadPulseMetrics();
            loadCompetitionHeatmap();
            loadTrendingSkills();
        }, 3 * 60 * 1000);
    </script>
</body>

</html>