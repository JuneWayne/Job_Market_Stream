<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Job Market Live Dashboard</title>

    <!-- D3 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <!-- Leaflet MarkerCluster CSS (optional but makes clusters nicer) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 1.5rem;
            background: #0b1220;
            color: #f9fafb;
        }

        h1,
        h2 {
            margin-bottom: 0.25rem;
        }

        h1 {
            font-size: 1.8rem;
        }

        h2 {
            font-size: 1.3rem;
            margin-top: 1.5rem;
        }

        .subtitle {
            color: #9ca3af;
            font-size: 0.9rem;
            margin-bottom: 1.25rem;
        }

        .grid {
            display: grid;
            grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr);
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .card {
            background: #020617;
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #1f2937;
        }

        .card h3 {
            margin: 0 0 0.35rem 0;
            font-size: 1.05rem;
        }

        .card small {
            color: #6b7280;
            display: block;
            margin-bottom: 0.8rem;
        }

        .overview-grid {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .stat-pill {
            flex: 1 1 120px;
            background: radial-gradient(circle at top left, #0ea5e9, #1e293b);
            border-radius: 999px;
            padding: 0.75rem 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #e5e7eb;
            opacity: 0.9;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            margin-top: 0.25rem;
        }

        svg {
            width: 100%;
            height: 280px;
            overflow: visible;
        }

        .axis path,
        .axis line {
            stroke: #4b5563;
        }

        .axis text {
            fill: #9ca3af;
            font-size: 11px;
        }

        .line {
            fill: none;
            stroke-width: 2.3px;
        }

        .bar {
            shape-rendering: crispEdges;
        }

        .legend {
            font-size: 0.75rem;
            fill: #9ca3af;
        }

        .error-msg {
            color: #f97373;
            font-size: 0.85rem;
        }

        a {
            color: #38bdf8;
            text-decoration: none;
        }

        /* ===== Map + Beeswarm layout ===== */

        #map-beeswarm-wrapper {
            margin-top: 2rem;
            display: flex;
            gap: 1rem;
            height: 600px;
        }

        #map-container {
            flex: 1.2;
            position: relative;
            background: #020617;
            border-radius: 0.75rem;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #1f2937;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        #map-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 23, 42, 0.96);
            color: #e5e7eb;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            font-size: 13px;
            z-index: 1001;
        }

        #map-legend h4 {
            margin: 0 0 6px 0;
            font-size: 0.9rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .legend-circle {
            display: inline-block;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .legend-circle.low {
            background: #4A90E2;
        }

        .legend-circle.medium {
            background: #F39C12;
        }

        .legend-circle.high {
            background: #27AE60;
        }

        .legend-circle.unknown {
            background: #7f8c8d;
        }

        .custom-marker {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            line-height: 30px;
            transition: transform .2s;
            user-select: none;
        }

        .custom-marker:hover {
            transform: translateY(-8px) scale(1.1);
            cursor: pointer;
        }

        .marker-low-a {
            background: #4A90E2;
        }

        .marker-low-b {
            background: #2C82C9;
        }

        .marker-medium-a {
            background: #F39C12;
        }

        .marker-medium-b {
            background: #D68910;
        }

        .marker-high-a {
            background: #27AE60;
        }

        .marker-high-b {
            background: #1E8449;
        }

        .marker-unknown {
            background: #7f8c8d;
        }

        .leaflet-div-icon,
        .leaflet-marker-icon {
            background: none !important;
            border: none !important;
        }

        .cluster-marker-icon .cluster-marker {
            width: 40px;
            height: 40px;
            line-height: 40px;
            border-radius: 50%;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            background: #27AE60;
        }

        .leaflet-marker-icon.dim {
            filter: grayscale(1) opacity(0.25);
        }

        /* Beeswarm panel */

        #beeswarm-panel {
            flex: 0.9;
            background: #020617;
            border-radius: 0.75rem;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #1f2937;
            padding: 10px 10px 6px 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        #beeswarm-header {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        #beeswarm-header .title {
            font-weight: 600;
            font-size: 1rem;
            margin-right: auto;
        }

        .segmented {
            display: inline-flex;
            background: #111827;
            border-radius: 999px;
            padding: 4px;
            gap: 4px;
        }

        .segmented button {
            border: 0;
            background: transparent;
            padding: 6px 10px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 0.78rem;
            font-weight: 600;
            color: #e5e7eb;
        }

        .segmented button.active {
            background: #0b1220;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        #bs-chips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            max-height: 90px;
            overflow-y: auto;
            padding-bottom: 4px;
        }

        .chip {
            border: 1px solid #1f2937;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 0.7rem;
            cursor: pointer;
            background: #020617;
            color: #e5e7eb;
            user-select: none;
            white-space: nowrap;
        }

        .chip.active {
            background: #f9fafb;
            color: #020617;
            border-color: #f9fafb;
        }

        #beeswarm-svg {
            width: 100%;
            flex: 1;
            background: radial-gradient(circle at top, #020617, #020617);
            border-radius: 8px;
        }

        .bs-tip {
            position: fixed;
            pointer-events: none;
            z-index: 3000;
            background: #0f172a;
            color: #f9fafb;
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 6px;
            box-shadow: 0 8px 22px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity .12s ease;
            max-width: 260px;
            line-height: 1.3;
        }

        .group-label {
            font-size: 10px;
            fill: #e5e7eb;
            paint-order: stroke;
            stroke: #020617;
            stroke-width: 6px;
        }

        .job-card.highlight {
            outline: 2px solid #4A90E2;
            border-radius: 6px;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.25);
        }

        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(0deg);
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top-color: #4A90E2;
            border-radius: 50%;
            animation: spinner-rotate 1s linear infinite;
            z-index: 3000;
            display: none;
            pointer-events: none;
        }

        @keyframes spinner-rotate {
            from {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        .popup-content {
            max-width: 340px;
            max-height: 320px;
            overflow-y: auto;
        }
    </style>
</head>

<body>
    <h1>Job Market Live Dashboard</h1>
    <div class="subtitle">
        Historical trends (all collected jobs) on the left • Last 7 days snapshot on the right.
    </div>

    <!-- Overview row -->
    <div class="card" id="overview-card">
        <h3>Overview</h3>
        <small>Summary of all jobs in DuckDB (<code>jobs</code> table)</small>
        <div class="overview-grid" id="overview-stats">
            <!-- Filled by JS -->
        </div>
        <div id="overview-error" class="error-msg"></div>
    </div>

    <div class="grid">
        <!-- Left: historical trends -->
        <div>
            <div class="card">
                <h3>Daily job postings</h3>
                <small>Last 180 days (all functions)</small>
                <div id="chart-daily"></div>
            </div>

            <div class="card">
                <h3>Job function distribution (all time)</h3>
                <small>Based on <code>job_function</code> classification</small>
                <div id="chart-func-all"></div>
            </div>
        </div>

        <!-- Right: last 7 days snapshot -->
        <div>
            <div class="card">
                <h3>Job function (last 7 days)</h3>
                <small>Rolling 7-day window</small>
                <div id="chart-func-7d"></div>
            </div>

            <div class="card">
                <h3>Work mode (last 7 days)</h3>
                <small>Remote vs Hybrid vs On-site</small>
                <div id="chart-workmode-7d"></div>
            </div>
        </div>
    </div>

    <!-- Map + Beeswarm -->
    <h2>Live Map & Beeswarm Explorer</h2>
    <div class="subtitle">
        Explore where postings are clustered and how they distribute by function, industry, company type, time posted,
        skills, and degree.
    </div>

    <div id="map-beeswarm-wrapper">
        <div id="map-container">
            <div id="map-legend">
                <h4>Average applicants</h4>
                <div class="legend-item"><span class="legend-circle low"></span> Low (1–60)</div>
                <div class="legend-item"><span class="legend-circle medium"></span> Medium (61–100)</div>
                <div class="legend-item"><span class="legend-circle high"></span> High (101+)</div>
                <div class="legend-item"><span class="legend-circle unknown"></span> Unknown</div>
            </div>
            <div id="map"></div>
        </div>

        <div id="beeswarm-panel">
            <div id="beeswarm-header">
                <div class="title">Jobs Beeswarm</div>
                <div class="segmented">
                    <button data-dim="jobFunction" class="active">Job Function</button>
                    <button data-dim="industry">Industry</button>
                    <button data-dim="companies">Companies</button>
                    <button data-dim="time">Time Posted</button>
                    <button data-dim="skills">Skills</button>
                    <button data-dim="degree">Degree</button>
                </div>
            </div>
            <div id="bs-chips"></div>
            <svg id="beeswarm-svg"></svg>
        </div>
    </div>

    <div class="bs-tip" id="bs-tip"></div>
    <div id="spinner"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <script>
        // ===== API base for ALL calls =====
        const API_BASE = "https://job-market-stream.onrender.com";

        // ------------- Helpers -------------
        function renderError(containerId, msg) {
            const el = document.getElementById(containerId);
            if (el) el.textContent = msg;
        }

        // ------------- Overview fetch -------------
        async function loadOverview() {
            try {
                const res = await fetch(`${API_BASE}/api/overview`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();

                const container = d3.select("#overview-stats");
                container.selectAll("*").remove();

                const stats = [
                    { label: "Total Jobs", value: data.total_jobs },
                    { label: "Companies", value: data.unique_companies },
                    { label: "Locations", value: data.unique_locations },
                    { label: "Earliest Posting", value: data.earliest_posting?.slice(0, 10) || "N/A" },
                    { label: "Latest Posting", value: data.latest_posting?.slice(0, 10) || "N/A" },
                ];

                const pills = container.selectAll(".stat-pill")
                    .data(stats)
                    .enter()
                    .append("div")
                    .attr("class", "stat-pill");

                pills.append("div")
                    .attr("class", "stat-label")
                    .text(d => d.label.toUpperCase());

                pills.append("div")
                    .attr("class", "stat-value")
                    .text(d => d.value);
            } catch (err) {
                console.error("Error loading overview", err);
                renderError("overview-error", "Failed to load overview stats.");
            }
        }

        // ------------- Line chart: daily counts -------------
        function drawDailyLineChart(containerId, data) {
            const container = d3.select(`#${containerId}`);
            container.selectAll("*").remove();

            if (!data || data.length === 0) {
                container.append("div").attr("class", "error-msg").text("No data.");
                return;
            }

            const parseDate = d => new Date(d.day);
            data.forEach(d => {
                d.date = parseDate(d);
                d.job_count = +d.job_count;
            });

            const margin = { top: 20, right: 20, bottom: 35, left: 45 };
            const width = container.node().clientWidth || 600;
            const height = 260;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleUtc()
                .domain(d3.extent(data, d => d.date))
                .range([0, innerWidth]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.job_count) || 1])
                .nice()
                .range([innerHeight, 0]);

            const xAxis = d3.axisBottom(x)
                .ticks(6)
                .tickFormat(d3.timeFormat("%b %d"));

            const yAxis = d3.axisLeft(y).ticks(5);

            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(xAxis);

            g.append("g")
                .attr("class", "axis")
                .call(yAxis);

            const line = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.job_count))
                .curve(d3.curveMonotoneX);

            g.append("path")
                .datum(data)
                .attr("class", "line")
                .attr("stroke", "#38bdf8")
                .attr("d", line);

            // small fading dots
            g.selectAll("circle.point")
                .data(data)
                .enter()
                .append("circle")
                .attr("class", "point")
                .attr("cx", d => x(d.date))
                .attr("cy", d => y(d.job_count))
                .attr("r", 2)
                .attr("fill", "#e5e7eb")
                .attr("opacity", 0.8);
        }

        async function loadDailyCounts() {
            try {
                const res = await fetch(`${API_BASE}/api/daily_counts?days=180`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                drawDailyLineChart("chart-daily", data);
            } catch (err) {
                console.error("Error loading daily counts", err);
                const container = d3.select("#chart-daily");
                container.append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load daily counts.");
            }
        }

        // ------------- Bar chart helper -------------
        function drawBarChart(containerId, data, { xKey, yKey, color = "#4ade80", maxBars = null } = {}) {
            const container = d3.select(`#${containerId}`);
            container.selectAll("*").remove();

            if (!data || data.length === 0) {
                container.append("div").attr("class", "error-msg").text("No data.");
                return;
            }

            if (maxBars && data.length > maxBars) {
                data = data.slice(0, maxBars);
            }

            const margin = { top: 20, right: 20, bottom: 70, left: 55 };
            const width = container.node().clientWidth || 500;
            const height = 260;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand()
                .domain(data.map(d => d[xKey]))
                .range([0, innerWidth])
                .padding(0.15);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d[yKey]) || 1])
                .nice()
                .range([innerHeight, 0]);

            const xAxis = d3.axisBottom(x)
                .tickFormat(d => d.length > 15 ? d.slice(0, 13) + "…" : d);

            const yAxis = d3.axisLeft(y).ticks(5);

            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(xAxis)
                .selectAll("text")
                .attr("transform", "rotate(-35)")
                .style("text-anchor", "end");

            g.append("g")
                .attr("class", "axis")
                .call(yAxis);

            g.selectAll(".bar")
                .data(data)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d[xKey]))
                .attr("y", d => y(d[yKey]))
                .attr("width", x.bandwidth())
                .attr("height", d => innerHeight - y(d[yKey]))
                .attr("fill", color)
                .attr("opacity", 0.9);
        }

        // ------------- Jobs by function (all time + 7 days) -------------
        async function loadJobsByFunctionAll() {
            try {
                const res = await fetch(`${API_BASE}/api/jobs_by_function`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                data.forEach(d => d.count = +d.count);
                drawBarChart("chart-func-all", data, {
                    xKey: "job_function",
                    yKey: "count",
                    color: "#a855f7",
                    maxBars: 15
                });
            } catch (err) {
                console.error("Error loading jobs_by_function all", err);
                d3.select("#chart-func-all")
                    .append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load job function data.");
            }
        }

        async function loadJobsByFunction7d() {
            try {
                const res = await fetch(`${API_BASE}/api/jobs_by_function?days=7`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                data.forEach(d => d.count = +d.count);
                drawBarChart("chart-func-7d", data, {
                    xKey: "job_function",
                    yKey: "count",
                    color: "#22c55e",
                    maxBars: 12
                });
            } catch (err) {
                console.error("Error loading jobs_by_function 7d", err);
                d3.select("#chart-func-7d")
                    .append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load recent job function data.");
            }
        }

        // ------------- Work mode (7 days) -------------
        async function loadWorkMode7d() {
            try {
                const res = await fetch(`${API_BASE}/api/work_mode?days=7`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                data.forEach(d => d.count = +d.count);
                drawBarChart("chart-workmode-7d", data, {
                    xKey: "work_mode",
                    yKey: "count",
                    color: "#f97316",
                    maxBars: 5
                });
            } catch (err) {
                console.error("Error loading work_mode 7d", err);
                d3.select("#chart-workmode-7d")
                    .append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load work mode data.");
            }
        }
    </script>

    <!-- Map + Beeswarm JS (adapted from your other site) -->
    <script>
        (async function () {
            const spinner = document.getElementById('spinner');
            spinner.style.display = 'block';

            function showError(msg) {
                const b = document.createElement('div');
                b.style = `position:absolute; top:0; left:0; right:0; background:rgba(200,0,0,0.9); color:white; padding:8px; font-family:sans-serif; z-index:2000;`;
                b.textContent = 'Error loading map/beeswarm data: ' + msg;
                document.body.appendChild(b);
            }

            const slugify = str => (str || '').toString().toLowerCase().trim()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');

            let jobs, summaries, locations;

            try {
                const r1 = await fetch(`${API_BASE}/api/map_jobs`);
                if (!r1.ok) throw new Error(`map_jobs returned ${r1.status}`);
                jobs = await r1.json();

                const r2 = await fetch(`${API_BASE}/api/map_location_summaries`);
                if (!r2.ok) throw new Error(`map_location_summaries returned ${r2.status}`);
                summaries = await r2.json();

                const r3 = await fetch(`${API_BASE}/api/map_locations`);
                if (!r3.ok) throw new Error(`map_locations returned ${r3.status}`);
                locations = await r3.json();
            } catch (e) {
                console.error(e);
                showError(e.message);
            } finally {
                spinner.style.display = 'none';
            }

            if (!(jobs && summaries && locations)) return;

            /* ---------- Map ---------- */
            const jobData = {};
            jobs.forEach(job => {
                const k = (job.location || 'Unknown').trim().toLowerCase();
                (jobData[k] = jobData[k] || []).push(job);
            });

            const locationMeta = {};
            summaries.forEach(s => {
                const k = (s.location || 'Unknown').trim().toLowerCase();
                locationMeta[k] = {
                    jobCount: s.number_of_jobs,
                    avgApplicants: s.average_applicants
                };
            });

            window.map = L.map('map').setView([38.0356, -78.5034], 5);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);

            const clusters = L.markerClusterGroup({
                spiderfyOnMaxZoom: true,
                showCoverageOnHover: false,
                maxClusterRadius: z => z < 5 ? 200 : z < 8 ? 100 : z < 12 ? 50 : 20,
                iconCreateFunction: cluster => {
                    let sum = 0;
                    cluster.getAllChildMarkers().forEach(m => sum += (m.options.jobCount || 0));
                    return L.divIcon({
                        className: 'cluster-marker-icon',
                        html: `<div class="cluster-marker">${sum}</div>`,
                        iconSize: [40, 40],
                        iconAnchor: [20, 20]
                    });
                }
            });

            const markersByKey = {}, coordsByKey = {};
            const seen = new Set();
            locations.forEach((loc, i) => {
                const raw = loc.location || 'Unknown';
                const key = raw.trim().toLowerCase();
                if (seen.has(key)) return;
                seen.add(key);

                const { latitude: lat, longitude: lng } = loc;
                if (lat == null || lng == null) return;

                const meta = locationMeta[key] || { jobCount: 0, avgApplicants: 0 };
                const jobsHere = jobData[key] || [];
                const count = jobsHere.length;
                const avg = meta.avgApplicants || 0;

                let level = 'unknown';
                if (avg > 0 && avg < 60) level = 'low';
                else if (avg >= 60 && avg < 100) level = 'medium';
                else if (avg >= 100) level = 'high';

                const variant = (i % 2 === 0) ? 'a' : 'b';
                const cls = level === 'unknown' ? 'marker-unknown' : `marker-${level}-${variant}`;

                const icon = L.divIcon({
                    html: `<div class="custom-marker ${cls}" title="${raw}: ${count} job${count !== 1 ? 's' : ''}">${count}</div>`,
                    iconSize: [34, 34],
                    iconAnchor: [17, 34]
                });

                const marker = L.marker([lat, lng], { icon, jobCount: count });

                const listId = `jobs-list-${slugify(key)}`;
                let popupHTML = `
          <div class="popup-content">
            <b>${raw}</b><br>
            ${count} job${count !== 1 ? 's' : ''}<br>
            Avg applicants: ${Math.round(avg || 0)}<br>
            <hr>
            <div id="${listId}" style="max-height:300px; overflow-y:auto; padding-right:6px;">`;

                jobsHere.forEach(job => {
                    const cardId = slugify(`${job.job_title} ${job.company_name || ''}`);
                    const jobLink = (job.job_link && job.job_link !== 'N/A') ? job.job_link : null;
                    popupHTML += `
            <div id="${cardId}" class="job-card" style="text-align:left; margin-bottom:10px;">
              <strong style="font-size:18px;">
                ${jobLink
                            ? `<a href="${jobLink}" target="_blank" rel="noopener noreferrer">${job.job_title}</a>`
                            : job.job_title}
              </strong><br>
              <div style="font-size:13px;">
                <strong>Company:</strong> ${job.company_name || 'N/A'}<br>
                <strong>Time Posted:</strong> ${job.time_posted || 'N/A'}<br>
                <strong>Applicants:</strong> ${job.num_applicants ?? 'N/A'}<br>
                <strong>Employment Type:</strong> ${job.employment_type || 'N/A'}<br>
                <strong>Seniority Level:</strong> ${job.seniority_level || 'N/A'}<br>
                <strong>Job Function:</strong> ${job.job_function || 'N/A'}<br>
                <strong>Industry:</strong> ${job.industry || 'N/A'}<br>
                <strong>Skills Desired:</strong> ${job.skills_desired || 'N/A'}<br>
                <strong>Degree Qualifications:</strong> ${job.degree_qualifications || 'N/A'}<br>
                <strong>Summary:</strong> ${job.summary || 'N/A'}<br>
              </div>
            </div><hr>`;
                });

                popupHTML += `</div></div>`;
                marker.bindPopup(popupHTML);
                clusters.addLayer(marker);
                markersByKey[key] = marker;
                coordsByKey[key] = [lat, lng];
            });

            map.addLayer(clusters);

            /* ---------- Beeswarm ---------- */

            const clean = v => (v || 'Unknown').toString().trim();
            const firstToken = v => clean(v).split(',')[0].split('/')[0].trim() || 'Unknown';

            function degreeLevel(text = '') {
                const v = text.toLowerCase();
                if (/(ph\.?d|doctor|doctoral|dphil)/.test(v)) return 'PhD';
                if (/(master|m\.s\.|ms\b|m\.sc)/.test(v)) return "Master's";
                if (/(bachelor|b\.s\.|bs\b|ba\b|b\.a\.|bsc)/.test(v)) return "Bachelor's";
                if (/(associate|a\.s\.|aa\b)/.test(v)) return "Associate's";
                if (/high\s*school|ged/.test(v)) return 'High School';
                if (/(enrolled|pursuing|working toward|currently)/.test(v)) return 'Enrolled';
                return 'Other';
            }

            function bucketTime(str) {
                const v = (str || '').toLowerCase().trim();
                if (!v) return 'Unknown';
                if (v.includes('hour')) return 'Last 24h';
                if (v.includes('just now')) return 'Last 24h';
                if (v.includes('day')) {
                    const m = v.match(/(\d+)/);
                    if (!m) return 'Past week';
                    const n = +m[1];
                    if (n <= 1) return 'Last 24h';
                    if (n <= 7) return 'Past week';
                    if (n <= 30) return 'Past month';
                    return 'Older';
                }
                if (v.includes('week')) return 'Past month';
                if (v.includes('month')) return 'Older';
                return 'Unknown';
            }

            const toInt = x => {
                if (x == null) return null;
                const m = x.toString().match(/\d+/);
                return m ? +m[0] : null;
            };

            const nodes = jobs.map((j, i) => {
                const locationKey = clean(j.location).toLowerCase();
                const locationSlug = slugify(locationKey);
                const applicants = toInt(j.num_applicants);
                return {
                    id: i,
                    title: clean(j.job_title),
                    company: clean(j.company_name),
                    locationRaw: clean(j.location),
                    locationKey,
                    locationSlug,
                    jobSlug: slugify(`${j.job_title} ${j.company_name || ''}`),
                    coords: coordsByKey[locationKey] || null,
                    applicants,
                    appLevel: applicants == null ? 'unknown' : (applicants < 60 ? 'low' : (applicants < 100 ? 'medium' : 'high')),
                    jobFunction: firstToken(j.job_function),
                    industry: firstToken(j.industry),
                    timeBucket: bucketTime(j.time_posted),
                    degreeLevel: degreeLevel(j.degree_qualifications || ''),
                    skillsDyn: (j.skills_desired || '').split(',').map(s => s.trim()).filter(Boolean),
                    jobLink: j.job_link
                };
            });

            function topK(arr, acc, k = 8) {
                const m = d3.rollup(arr, v => v.length, d => acc(d));
                return Array.from(m, ([name, count]) => ({ name, count }))
                    .sort((a, b) => d3.descending(a.count, b.count))
                    .slice(0, k)
                    .map(d => d.name);
            }

            const topFunctions = topK(nodes, d => d.jobFunction, 8);
            const topIndustries = topK(nodes, d => d.industry, 8);
            const degreeGroups = ["Bachelor's", "Master's", 'PhD', "Associate's", 'Enrolled', 'High School', 'Other'];

            function companyBucket(name = '') {
                const n = name.toLowerCase();
                if (!n) return 'Other';
                if (/(google|alphabet|meta|facebook|amazon|apple|microsoft|nvidia|netflix)/.test(n)) return 'Tech Giants';
                if (/(mckinsey|boston consulting|bcg|bain|deloitte|pwc|kpmg|ey|accen)/.test(n)) return 'Consulting/Big 4';
                if (/(goldman sachs|jpmorgan|jp morgan|morgan stanley|citadel|two sigma|blackrock|fidelity|citibank|bank of america|wells fargo)/.test(n)) return 'Finance';
                return 'Other';
            }

            function skillGroup(d) {
                const s = d.skillsDyn && d.skillsDyn[0];
                return s || 'Other';
            }

            function groupValue(dim, d) {
                if (dim === 'jobFunction') return topFunctions.includes(d.jobFunction) ? d.jobFunction : 'Other';
                if (dim === 'industry') return topIndustries.includes(d.industry) ? d.industry : 'Other';
                if (dim === 'companies') return companyBucket(d.company);
                if (dim === 'time') return d.timeBucket;
                if (dim === 'degree') return degreeGroups.includes(d.degreeLevel) ? d.degreeLevel : 'Other';
                if (dim === 'skills') return skillGroup(d);
                return 'Other';
            }

            const DIMENSIONS = {
                jobFunction: { label: 'Job Function', groups: [...topFunctions].sort(d3.ascending).concat('Other') },
                industry: { label: 'Industry', groups: [...topIndustries].sort(d3.ascending).concat('Other') },
                companies: { label: 'Companies', groups: ['Tech Giants', 'Consulting/Big 4', 'Finance', 'Other'] },
                time: { label: 'Time Posted', groups: ['Last 24h', 'Past week', 'Past month', 'Older', 'Unknown'] },
                degree: { label: 'Degree', groups: degreeGroups },
                skills: { label: 'Skills', groups: Array.from(new Set(nodes.flatMap(n => n.skillsDyn))).slice(0, 12).concat('Other') }
            };

            const panel = document.getElementById('beeswarm-panel');
            const svg = d3.select('#beeswarm-svg');
            const tip = d3.select('#bs-tip');

            function panelInnerSize() {
                const rect = panel.getBoundingClientRect();
                const W = rect.width, H = rect.height;
                const margin = { top: 8, right: 10, bottom: 8, left: 10 };
                return { W, H, margin, width: W - margin.left - margin.right, height: H - 140 - margin.top - margin.bottom };
            }

            let { W, H, margin, width, height } = panelInnerSize();

            svg.attr('viewBox', [0, 0, width + margin.left + margin.right, height + margin.top + margin.bottom].join(' '))
                .attr('preserveAspectRatio', 'xMidYMid meet');

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            function makeCentroids(groups) {
                const n = groups.length;
                const cols = (width >= 760) ? 3 : (width >= 520 ? 2 : 1);
                const rows = Math.ceil(n / cols);
                const xPad = 30, yPad = 36;
                const xs = d3.scalePoint().domain(d3.range(cols)).range([xPad, width - xPad]).padding(0.5);
                const ys = d3.scalePoint().domain(d3.range(rows)).range([yPad, height - yPad]).padding(0.6);
                const map = new Map();
                groups.forEach((name, i) => {
                    const c = i % cols;
                    const r = Math.floor(i / cols);
                    map.set(name, { x: xs(c), y: ys(r) });
                });
                return map;
            }

            let currentDim = 'jobFunction';
            let centroids = makeCentroids(DIMENSIONS[currentDim].groups);

            const rScale = d3.scaleSqrt()
                .domain([0, d3.max(nodes, d => d.applicants || 0) || 1])
                .range([3, 11]);

            const colorByApplicants = d =>
                d.appLevel === 'low' ? '#4A90E2' :
                    d.appLevel === 'medium' ? '#F39C12' :
                        d.appLevel === 'high' ? '#27AE60' : '#7f8c8d';

            const circles = g.append('g')
                .attr('class', 'circles')
                .selectAll('circle')
                .data(nodes, d => d.id)
                .join('circle')
                .attr('r', d => rScale(d.applicants || 0))
                .attr('fill', colorByApplicants)
                .attr('stroke', 'rgba(0,0,0,0.25)')
                .attr('stroke-width', 0.5)
                .style('cursor', 'pointer')
                .on('mouseenter', function (event, d) {
                    d3.select(this).attr('stroke-width', 1.4);
                    const skillsTxt = d.skillsDyn && d.skillsDyn.length
                        ? (' • ' + d.skillsDyn.slice(0, 6).join(', '))
                        : '';
                    tip.style('opacity', 1)
                        .html(`<b>${d.title}</b><br>${d.company} — ${d.locationRaw}<br><i>${d.jobFunction} • ${d.industry} • ${d.timeBucket} • ${d.degreeLevel}${skillsTxt}</i>`);
                })
                .on('mousemove', function (event) {
                    tip.style('left', (event.clientX + 10) + 'px')
                        .style('top', (event.clientY + 10) + 'px');
                })
                .on('mouseleave', function () {
                    d3.select(this).attr('stroke-width', 0.5);
                    tip.style('opacity', 0);
                })
                .on('click', (event, d) => {
                    if (!d.coords) return;
                    const mk = markersByKey[d.locationKey];
                    if (!mk) return;
                    clusters.zoomToShowLayer(mk, () => {
                        mk.openPopup();
                        const listEl = document.getElementById(`jobs-list-${d.locationSlug}`);
                        const target = listEl && document.getElementById(d.jobSlug);
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            target.classList.add('highlight');
                            setTimeout(() => target.classList.remove('highlight'), 1300);
                        }
                    });
                });

            const labelLayer = g.append('g').attr('class', 'group-labels');
            let labelSel;

            function renderGroupLabels() {
                const groups = DIMENSIONS[currentDim].groups;
                const items = labelLayer.selectAll('g.gl')
                    .data(groups, d => d);

                const enter = items.enter()
                    .append('g')
                    .attr('class', 'gl');

                enter.append('text')
                    .attr('class', 'group-label')
                    .attr('text-anchor', 'start')
                    .attr('dominant-baseline', 'middle')
                    .text(d => d);

                items.exit().remove();
                labelSel = labelLayer.selectAll('g.gl').select('text.group-label');
            }

            function updateGroupLabelPositions() {
                if (!labelSel) return;
                const stats = new Map();
                nodes.forEach(n => {
                    const gname = groupValue(currentDim, n);
                    if (!stats.has(gname)) stats.set(gname, { maxRight: -Infinity, sumY: 0, count: 0 });
                    const st = stats.get(gname);
                    const r = rScale(n.applicants || 0);
                    const right = (n.x || 0) + r;
                    st.maxRight = Math.max(st.maxRight, right);
                    st.sumY += (n.y || 0);
                    st.count++;
                });

                labelSel.each(function (name) {
                    const st = stats.get(name);
                    if (!st || !st.count) {
                        d3.select(this).attr('opacity', 0);
                        return;
                    }
                    const y = st.sumY / st.count;
                    const x = Math.min(st.maxRight + 8, width - 4);
                    d3.select(this)
                        .attr('opacity', 1)
                        .attr('x', x)
                        .attr('y', y);
                });
            }

            const sim = d3.forceSimulation(nodes)
                .alpha(1)
                .velocityDecay(0.3)
                .force('x', d3.forceX(d => centroids.get(groupValue(currentDim, d)).x).strength(0.12))
                .force('y', d3.forceY(d => centroids.get(groupValue(currentDim, d)).y).strength(0.12))
                .force('collide', d3.forceCollide(d => rScale(d.applicants || 0) + 1.3))
                .on('tick', () => {
                    circles
                        .attr('cx', d => d.x = Math.max(8, Math.min(width - 8, d.x || width / 2)))
                        .attr('cy', d => d.y = Math.max(8, Math.min(height - 8, d.y || height / 2)));
                    updateGroupLabelPositions();
                });

            renderGroupLabels();
            updateGroupLabelPositions();

            // Chips
            let activeChip = 'All';
            const chipsWrap = d3.select('#bs-chips');

            function renderChips() {
                const cats = ['All', ...DIMENSIONS[currentDim].groups];
                const chips = chipsWrap.selectAll('div.chip')
                    .data(cats, d => d);

                chips.enter()
                    .append('div')
                    .attr('class', d => `chip${d === activeChip ? ' active' : ''}`)
                    .text(d => d)
                    .on('click', (_, val) => {
                        activeChip = val;
                        chipsWrap.selectAll('.chip').classed('active', d => d === val);
                        applyFilterToNodesAndMap();
                    });

                chips.classed('active', d => d === activeChip).text(d => d);
                chips.exit().remove();
            }

            renderChips();

            function applyFilterToNodesAndMap() {
                circles.transition().duration(200)
                    .style('opacity', d => (activeChip === 'All' || groupValue(currentDim, d) === activeChip) ? 1 : 0.15);

                const allowKeys = new Set(
                    activeChip === 'All'
                        ? nodes.map(n => n.locationKey)
                        : nodes.filter(n => groupValue(currentDim, n) === activeChip).map(n => n.locationKey)
                );

                Object.entries(markersByKey).forEach(([k, mk]) => {
                    const el = mk.getElement && mk.getElement();
                    if (!el) return;
                    if (allowKeys.has(k)) el.classList.remove('dim');
                    else el.classList.add('dim');
                });
            }

            applyFilterToNodesAndMap();

            // Dimension switch
            const segButtons = d3.selectAll('.segmented button');
            segButtons.on('click', function () {
                const dim = this.getAttribute('data-dim');
                if (dim === currentDim) return;
                d3.selectAll('.segmented button').classed('active', false);
                d3.select(this).classed('active', true);
                currentDim = dim;
                centroids = makeCentroids(DIMENSIONS[currentDim].groups);
                renderGroupLabels();
                activeChip = 'All';
                renderChips();
                sim.force('x', d3.forceX(d => centroids.get(groupValue(currentDim, d)).x).strength(0.12));
                sim.force('y', d3.forceY(d => centroids.get(groupValue(currentDim, d)).y).strength(0.12));
                sim.alpha(0.9).restart();
                applyFilterToNodesAndMap();
                updateGroupLabelPositions();
            });

            // Resize relayout
            function relayout() {
                ({ W, H, margin, width, height } = panelInnerSize());
                svg.attr('viewBox', [0, 0, width + margin.left + margin.right, height + margin.top + margin.bottom].join(' '));
                centroids = makeCentroids(DIMENSIONS[currentDim].groups);
                renderGroupLabels();
                sim.force('x', d3.forceX(d => centroids.get(groupValue(currentDim, d)).x).strength(0.12));
                sim.force('y', d3.forceY(d => centroids.get(groupValue(currentDim, d)).y).strength(0.12));
                sim.alpha(0.4).restart();
                updateGroupLabelPositions();
            }

            window.addEventListener('resize', relayout);
        })();

        // Kick off the original dashboard pieces
        loadOverview();
        loadDailyCounts();
        loadJobsByFunctionAll();
        loadJobsByFunction7d();
        loadWorkMode7d();
    </script>
</body>

</html>