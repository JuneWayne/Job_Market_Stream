<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Job Market Live Dashboard</title>

    <!-- D3 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Leaflet + MarkerCluster for map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 1.5rem;
            background: #020617;
            color: #f9fafb;
        }

        h1,
        h2 {
            margin-bottom: 0.25rem;
        }

        h1 {
            font-size: 1.8rem;
        }

        h2 {
            font-size: 1.3rem;
            margin-top: 1.5rem;
        }

        .subtitle {
            color: #9ca3af;
            font-size: 0.9rem;
            margin-bottom: 1.25rem;
        }

        .grid {
            display: grid;
            grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr);
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .today-grid {
            display: grid;
            grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.3fr);
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .card {
            background: #020617;
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #1f2937;
        }

        .card h3 {
            margin: 0 0 0.35rem 0;
            font-size: 1.05rem;
        }

        .card small {
            color: #6b7280;
            display: block;
            margin-bottom: 0.8rem;
        }

        .overview-grid {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .stat-pill {
            flex: 1 1 120px;
            background: radial-gradient(circle at top left, #0ea5e9, #1e293b);
            border-radius: 999px;
            padding: 0.75rem 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #e5e7eb;
            opacity: 0.9;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            margin-top: 0.25rem;
        }

        svg {
            width: 100%;
            height: 280px;
            overflow: visible;
        }

        .axis path,
        .axis line {
            stroke: #4b5563;
        }

        .axis text {
            fill: #9ca3af;
            font-size: 11px;
        }

        .line {
            fill: none;
            stroke-width: 2.3px;
        }

        .bar {
            shape-rendering: crispEdges;
        }

        .error-msg {
            color: #f97373;
            font-size: 0.85rem;
        }

        a {
            color: #38bdf8;
            text-decoration: none;
        }

        /* --- Map + Beeswarm layout --- */
        .map-beeswarm-grid {
            display: grid;
            grid-template-columns: minmax(0, 1.3fr) minmax(0, 1fr);
            gap: 1rem;
        }

        #map {
            width: 100%;
            height: 450px;
            border-radius: 0.75rem;
            overflow: hidden;
        }

        #map-legend {
            position: absolute;
            bottom: 12px;
            left: 14px;
            background: rgba(15, 23, 42, 0.96);
            padding: 8px 10px;
            border-radius: 0.5rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            font-size: 12px;
        }

        #map-legend h4 {
            margin: 0 0 4px 0;
            font-size: 12px;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .legend-circle {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 4px;
        }

        .legend-circle.low {
            background: #4A90E2;
        }

        .legend-circle.medium {
            background: #F39C12;
        }

        .legend-circle.high {
            background: #22c55e;
        }

        .legend-circle.unknown {
            background: #6b7280;
        }

        .custom-marker {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            line-height: 30px;
            transition: transform .2s;
            user-select: none;
        }

        .custom-marker:hover {
            transform: translateY(-8px) scale(1.08);
            cursor: pointer;
        }

        .marker-low {
            background: #4A90E2;
        }

        .marker-medium {
            background: #F39C12;
        }

        .marker-high {
            background: #22c55e;
        }

        .marker-unknown {
            background: #6b7280;
        }

        .leaflet-div-icon,
        .leaflet-marker-icon {
            background: none !important;
            border: none !important;
        }

        /* Beeswarm */
        #beeswarm-svg {
            width: 100%;
            height: 450px;
        }

        #bs-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        #bs-header .title {
            font-weight: 600;
            font-size: 0.95rem;
            margin-right: auto;
        }

        .segmented {
            display: inline-flex;
            background: #020617;
            border-radius: 999px;
            padding: 3px;
            gap: 3px;
            border: 1px solid #1f2937;
        }

        .segmented button {
            border: 0;
            background: transparent;
            padding: 5px 7px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 0.75rem;
            color: #e5e7eb;
        }

        .segmented button.active {
            background: #111827;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
        }

        #bs-chips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            max-height: 72px;
            overflow-y: auto;
            margin-bottom: 6px;
        }

        .chip {
            padding: 4px 9px;
            border-radius: 999px;
            font-size: 0.7rem;
            border: 1px solid #4b5563;
            cursor: pointer;
        }

        .chip.active {
            background: #e5e7eb;
            color: #020617;
            border-color: #e5e7eb;
        }

        .bs-tip {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            background: #020617;
            color: #f9fafb;
            font-size: 0.75rem;
            padding: 6px 8px;
            border-radius: 0.4rem;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
            opacity: 0;
            transition: opacity .12s ease;
            max-width: 260px;
            line-height: 1.3;
        }

        .group-label {
            font-size: 11px;
            fill: #e5e7eb;
            paint-order: stroke;
            stroke: #020617;
            stroke-width: 4px;
        }

        .leaflet-marker-icon.dim {
            filter: grayscale(1) opacity(0.25);
        }

        /* Recent jobs list */
        #recent-jobs-list {
            max-height: 320px;
            overflow-y: auto;
            margin-top: 0.25rem;
        }

        .job-card {
            border-radius: 0.6rem;
            border: 1px solid #1f2937;
            padding: 0.6rem 0.75rem;
            margin-bottom: 0.5rem;
            background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), rgba(15, 23, 42, 1));
        }

        .job-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .job-title-row h4 {
            margin: 0;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .job-meta {
            font-size: 0.78rem;
            color: #9ca3af;
            margin-top: 0.12rem;
        }

        .job-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            margin-top: 0.35rem;
        }

        .job-tag {
            font-size: 0.7rem;
            border-radius: 999px;
            padding: 2px 7px;
            border: 1px solid #334155;
            color: #e5e7eb;
        }

        .job-tag.primary {
            background: #22c55e;
            border-color: #22c55e;
            color: #022c22;
            font-weight: 600;
        }

        .job-tag.subtle {
            background: rgba(15, 23, 42, 0.9);
        }

        .job-apply {
            font-size: 0.7rem;
            padding: 4px 8px;
            border-radius: 999px;
            border: none;
            background: #38bdf8;
            color: #0b1120;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
        }

        .job-apply:hover {
            filter: brightness(1.1);
        }
    </style>
</head>

<body>
    <h1>Job Market Live Dashboard</h1>
    <div class="subtitle">
        Historical trends on the left • Fresh activity & live map on the right.
    </div>

    <!-- Overview row -->
    <div class="card" id="overview-card">
        <h3>Overall overview</h3>
        <small>Entire DuckDB <code>jobs</code> history</small>
        <div class="overview-grid" id="overview-stats"></div>
        <div id="overview-error" class="error-msg"></div>
    </div>

    <!-- Today snapshot + latest jobs -->
    <div class="today-grid">
        <div class="card">
            <h3>Today’s snapshot</h3>
            <small>Jobs posted in the last 24 hours (by time_posted_parsed)</small>
            <div class="overview-grid" id="today-stats"></div>
        </div>
        <div class="card">
            <h3>Latest jobs (last 24 hours)</h3>
            <small>Most recent postings with direct links</small>
            <div id="recent-jobs-list"></div>
        </div>
    </div>

    <div class="grid">
        <!-- Left: historical trends -->
        <div>
            <div class="card">
                <h3>Daily job postings</h3>
                <small>Last 180 days (all functions)</small>
                <div id="chart-daily"></div>
            </div>

            <div class="card">
                <h3>Job function distribution (all time)</h3>
                <small>Based on <code>job_function</code> classification</small>
                <div id="chart-func-all"></div>
            </div>
        </div>

        <!-- Right: last 7 days + last 24 hours -->
        <div>
            <div class="card">
                <h3>Job function (last 7 days)</h3>
                <small>Rolling 7-day window</small>
                <div id="chart-func-7d"></div>
            </div>

            <div class="card">
                <h3>Work mode (last 7 days)</h3>
                <small>Remote vs Hybrid vs On-site</small>
                <div id="chart-workmode-7d"></div>
            </div>

            <div class="card">
                <h3>New jobs in the last 24 hours</h3>
                <small>Each bubble is one hour; size = # of jobs. Latest hour is highlighted.</small>
                <div id="chart-24h-bubbles" style="position: relative;"></div>
            </div>
        </div>
    </div>

    <h2>Live Map & Beeswarm Explorer</h2>
    <div class="subtitle">
        Explore where fresh postings are clustered and how they distribute by function, industry,
        company type, time posted, skills, and degree (last 24 hours only).
    </div>

    <div class="card">
        <div class="map-beeswarm-grid">
            <div style="position: relative;">
                <div id="map"></div>
                <div id="map-legend">
                    <h4>Average applicants</h4>
                    <div class="legend-item"><span class="legend-circle low"></span> Low</div>
                    <div class="legend-item"><span class="legend-circle medium"></span> Medium</div>
                    <div class="legend-item"><span class="legend-circle high"></span> High</div>
                    <div class="legend-item"><span class="legend-circle unknown"></span> Unknown</div>
                </div>
            </div>

            <div>
                <div id="bs-header">
                    <div class="title">Jobs Beeswarm</div>
                    <div class="segmented">
                        <button data-dim="jobFunction" class="active">Job Function</button>
                        <button data-dim="industry">Industry</button>
                        <button data-dim="companyBucket">Companies</button>
                        <button data-dim="timeBucket">Time Posted</button>
                        <button data-dim="skills">Skills</button>
                        <button data-dim="degreeLevel">Degree</button>
                    </div>
                </div>
                <div id="bs-chips"></div>
                <svg id="beeswarm-svg"></svg>
            </div>
        </div>
        <div class="bs-tip" id="bs-tip"></div>
    </div>

    <script>
        const API_BASE = "https://job-market-stream.onrender.com";
        let mapInstance = null;

        // ---------- Helpers ----------
        function renderError(containerId, msg) {
            const el = document.getElementById(containerId);
            if (el) el.textContent = msg;
        }

        function mode(values, fallback = "Unknown") {
            const counts = new Map();
            values.forEach(v => {
                if (!v || v === "Unknown") return;
                counts.set(v, (counts.get(v) || 0) + 1);
            });
            if (!counts.size) return fallback;
            let best = null;
            let bestCount = -1;
            counts.forEach((cnt, key) => {
                if (cnt > bestCount) {
                    best = key;
                    bestCount = cnt;
                }
            });
            return best || fallback;
        }

        // ---------- Overview ----------
        async function loadOverview() {
            try {
                const res = await fetch(`${API_BASE}/api/overview`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();

                const container = d3.select("#overview-stats");
                container.selectAll("*").remove();

                const stats = [
                    { label: "Total Jobs", value: data.total_jobs },
                    { label: "Companies", value: data.unique_companies },
                    { label: "Locations", value: data.unique_locations },
                    { label: "Earliest Posting", value: data.earliest_posting?.slice(0, 10) || "N/A" },
                    { label: "Latest Posting", value: data.latest_posting?.slice(0, 10) || "N/A" },
                ];

                const pills = container.selectAll(".stat-pill")
                    .data(stats)
                    .enter()
                    .append("div")
                    .attr("class", "stat-pill");

                pills.append("div")
                    .attr("class", "stat-label")
                    .text(d => d.label.toUpperCase());

                pills.append("div")
                    .attr("class", "stat-value")
                    .text(d => d.value);
            } catch (err) {
                console.error("Error loading overview", err);
                renderError("overview-error", "Failed to load overview stats.");
            }
        }

        // ---------- Daily line chart ----------
        function drawDailyLineChart(containerId, data) {
            const container = d3.select(`#${containerId}`);
            container.selectAll("*").remove();

            if (!data || data.length === 0) {
                container.append("div").attr("class", "error-msg").text("No data.");
                return;
            }

            data.forEach(d => {
                d.date = new Date(d.day);
                d.job_count = +d.job_count;
            });

            const margin = { top: 20, right: 20, bottom: 35, left: 45 };
            const width = container.node().clientWidth || 600;
            const height = 260;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleUtc()
                .domain(d3.extent(data, d => d.date))
                .range([0, innerWidth]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.job_count) || 1])
                .nice()
                .range([innerHeight, 0]);

            const xAxis = d3.axisBottom(x)
                .ticks(6)
                .tickFormat(d3.timeFormat("%b %d"));

            const yAxis = d3.axisLeft(y).ticks(5);

            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(xAxis);

            g.append("g")
                .attr("class", "axis")
                .call(yAxis);

            const line = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.job_count))
                .curve(d3.curveMonotoneX);

            g.append("path")
                .datum(data)
                .attr("class", "line")
                .attr("stroke", "#38bdf8")
                .attr("d", line);

            g.selectAll("circle.point")
                .data(data)
                .enter()
                .append("circle")
                .attr("class", "point")
                .attr("cx", d => x(d.date))
                .attr("cy", d => y(d.job_count))
                .attr("r", 2)
                .attr("fill", "#e5e7eb")
                .attr("opacity", 0.8);
        }

        async function loadDailyCounts() {
            try {
                const res = await fetch(`${API_BASE}/api/daily_counts?days=180`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                drawDailyLineChart("chart-daily", data);
            } catch (err) {
                console.error("Error loading daily counts", err);
                d3.select("#chart-daily")
                    .append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load daily counts.");
            }
        }

        // ---------- Generic bar chart ----------
        function drawBarChart(containerId, data, { xKey, yKey, color = "#4ade80", maxBars = null } = {}) {
            const container = d3.select(`#${containerId}`);
            container.selectAll("*").remove();

            if (!data || data.length === 0) {
                container.append("div").attr("class", "error-msg").text("No data.");
                return;
            }

            if (maxBars && data.length > maxBars) {
                data = data.slice(0, maxBars);
            }

            const margin = { top: 20, right: 20, bottom: 70, left: 55 };
            const width = container.node().clientWidth || 500;
            const height = 260;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand()
                .domain(data.map(d => d[xKey]))
                .range([0, innerWidth])
                .padding(0.15);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d[yKey]) || 1])
                .nice()
                .range([innerHeight, 0]);

            const xAxis = d3.axisBottom(x)
                .tickFormat(d => d.length > 15 ? d.slice(0, 13) + "…" : d);

            const yAxis = d3.axisLeft(y).ticks(5);

            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(xAxis)
                .selectAll("text")
                .attr("transform", "rotate(-35)")
                .style("text-anchor", "end");

            g.append("g")
                .attr("class", "axis")
                .call(yAxis);

            g.selectAll(".bar")
                .data(data)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d[xKey]))
                .attr("y", d => y(d[yKey]))
                .attr("width", x.bandwidth())
                .attr("height", d => innerHeight - y(d[yKey]))
                .attr("fill", color)
                .attr("opacity", 0.9);
        }

        async function loadJobsByFunctionAll() {
            try {
                const res = await fetch(`${API_BASE}/api/jobs_by_function`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                data.forEach(d => d.count = +d.count);
                drawBarChart("chart-func-all", data, {
                    xKey: "job_function",
                    yKey: "count",
                    color: "#a855f7",
                    maxBars: 15
                });
            } catch (err) {
                console.error("Error loading jobs_by_function all", err);
                d3.select("#chart-func-all")
                    .append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load job function data.");
            }
        }

        async function loadJobsByFunction7d() {
            try {
                const res = await fetch(`${API_BASE}/api/jobs_by_function?days=7`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                data.forEach(d => d.count = +d.count);
                drawBarChart("chart-func-7d", data, {
                    xKey: "job_function",
                    yKey: "count",
                    color: "#22c55e",
                    maxBars: 12
                });
            } catch (err) {
                console.error("Error loading jobs_by_function 7d", err);
                d3.select("#chart-func-7d")
                    .append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load recent job function data.");
            }
        }

        async function loadWorkMode7d() {
            try {
                const res = await fetch(`${API_BASE}/api/work_mode?days=7`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                data.forEach(d => d.count = +d.count);
                drawBarChart("chart-workmode-7d", data, {
                    xKey: "work_mode",
                    yKey: "count",
                    color: "#f97316",
                    maxBars: 5
                });
            } catch (err) {
                console.error("Error loading work_mode 7d", err);
                d3.select("#chart-workmode-7d")
                    .append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load work mode data.");
            }
        }

        // ---------- 24h hourly bubble chart ----------
        function drawHourlyBubbleChart(containerId, data) {
            const container = d3.select(`#${containerId}`);
            container.selectAll("svg").remove();
            container.selectAll(".bs-tip").remove();

            if (!data || data.length === 0) {
                container.append("div")
                    .attr("class", "error-msg")
                    .text("No data for last 24 hours.");
                return;
            }

            data.forEach(d => {
                d.date = new Date(d.hour);
                d.job_count = +d.job_count;
            });

            const margin = { top: 20, right: 20, bottom: 35, left: 45 };
            const width = container.node().clientWidth || 500;
            const height = 260;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleTime()
                .domain(d3.extent(data, d => d.date))
                .range([0, innerWidth]);

            const maxCount = d3.max(data, d => d.job_count) || 1;

            const r = d3.scaleSqrt()
                .domain([0, maxCount])
                .range([5, 18]);

            const y = d3.scaleLinear()
                .domain([0, maxCount])
                .nice()
                .range([innerHeight, 0]);

            const xAxis = d3.axisBottom(x)
                .ticks(6)
                .tickFormat(d3.timeFormat("%H:%M"));

            const yAxis = d3.axisLeft(y).ticks(4);

            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(xAxis);

            g.append("g")
                .attr("class", "axis")
                .call(yAxis);

            const latestDate = d3.max(data, d => d.date);

            const tooltip = d3.select("#chart-24h-bubbles")
                .append("div")
                .attr("class", "bs-tip")
                .style("opacity", 0);

            g.selectAll("circle.hour-bubble")
                .data(data)
                .enter()
                .append("circle")
                .attr("class", "hour-bubble")
                .attr("cx", d => x(d.date))
                .attr("cy", d => y(d.job_count))
                .attr("r", d => r(d.job_count))
                .attr("fill", d =>
                    d.date.getTime() === latestDate.getTime()
                        ? "#22c55e"
                        : "#6b7280"
                )
                .attr("opacity", 0.9)
                .on("mouseenter", function (event, d) {
                    d3.select(this).attr("stroke", "#e5e7eb").attr("stroke-width", 1.4);
                    tooltip
                        .style("opacity", 1)
                        .html(
                            `<strong>${d3.timeFormat("%b %d, %H:00")(d.date)}</strong><br>` +
                            `${d.job_count} job${d.job_count === 1 ? "" : "s"}`
                        )
                        .style("left", (event.offsetX + 20) + "px")
                        .style("top", (event.offsetY + 10) + "px");
                })
                .on("mousemove", function (event) {
                    tooltip
                        .style("left", (event.offsetX + 20) + "px")
                        .style("top", (event.offsetY + 10) + "px");
                })
                .on("mouseleave", function () {
                    d3.select(this).attr("stroke-width", 0);
                    tooltip.style("opacity", 0);
                });
        }

        async function loadHourlyCounts24h() {
            try {
                const res = await fetch(`${API_BASE}/api/hourly_counts?hours=24`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                drawHourlyBubbleChart("chart-24h-bubbles", data);
            } catch (err) {
                console.error("Error loading hourly counts", err);
                const container = d3.select("#chart-24h-bubbles");
                container.append("div")
                    .attr("class", "error-msg")
                    .text("Failed to load last-24-hours data.");
            }
        }

        // ---------- Today snapshot + recent jobs ----------
        function updateTodaySnapshot(jobs) {
            const container = d3.select("#today-stats");
            if (container.empty()) return;
            container.selectAll("*").remove();

            if (!jobs || !jobs.length) {
                container.append("div").attr("class", "error-msg").text("No jobs in the last 24 hours.");
                return;
            }

            const total = jobs.length;
            const remote = jobs.filter(j => (j.work_mode || "").toLowerCase().includes("remote")).length;
            const hybrid = jobs.filter(j => (j.work_mode || "").toLowerCase().includes("hybrid")).length;
            const onsite = jobs.filter(j => (j.work_mode || "").toLowerCase().includes("on-site") || (j.work_mode || "").toLowerCase().includes("on site")).length;

            const remoteShare = total ? Math.round(remote * 100 / total) : 0;

            const topFunction = mode(jobs.map(j => j.job_function || j["Job Function"] || "Unknown"));
            const topLocation = mode(jobs.map(j => j.location || "Unknown"));

            const stats = [
                { label: "New jobs (24h)", value: total },
                { label: "Remote share", value: `${remoteShare}%` },
                { label: "Top function", value: topFunction },
                { label: "Most active city", value: topLocation },
            ];

            const pills = container.selectAll(".stat-pill")
                .data(stats)
                .enter()
                .append("div")
                .attr("class", "stat-pill");

            pills.append("div")
                .attr("class", "stat-label")
                .text(d => d.label.toUpperCase());

            pills.append("div")
                .attr("class", "stat-value")
                .text(d => d.value);
        }

        function renderRecentJobs(jobs) {
            const container = document.getElementById("recent-jobs-list");
            if (!container) return;
            container.innerHTML = "";

            if (!jobs || !jobs.length) {
                const msg = document.createElement("div");
                msg.className = "error-msg";
                msg.textContent = "No jobs in the last 24 hours.";
                container.appendChild(msg);
                return;
            }

            const latestJobs = jobs.slice(0, 40); // show top 40 most recent

            latestJobs.forEach(job => {
                const title = job.job_title || "Untitled role";
                const company = job.company_name || "Unknown company";
                const location = job.location || "Unknown location";
                const fn = job.job_function || job["Job Function"] || "Unknown";
                const workMode = job.work_mode || "Work mode N/A";
                const age = job.time_posted || ""; // "2 hours ago"
                const link = job.job_link || job.application_link || null;

                const card = document.createElement("div");
                card.className = "job-card";

                const titleRow = document.createElement("div");
                titleRow.className = "job-title-row";

                const h4 = document.createElement("h4");
                if (link) {
                    h4.innerHTML = `<a href="${link}" target="_blank" rel="noopener noreferrer">${title}</a>`;
                } else {
                    h4.textContent = title;
                }
                titleRow.appendChild(h4);

                if (link) {
                    const btn = document.createElement("button");
                    btn.className = "job-apply";
                    btn.textContent = "View";
                    btn.onclick = () => window.open(link, "_blank", "noopener");
                    titleRow.appendChild(btn);
                }

                const meta = document.createElement("div");
                meta.className = "job-meta";
                meta.textContent = `${company} • ${location}${age ? " • " + age : ""}`;

                const tags = document.createElement("div");
                tags.className = "job-tags";

                const fnTag = document.createElement("span");
                fnTag.className = "job-tag primary";
                fnTag.textContent = fn;
                tags.appendChild(fnTag);

                const wmTag = document.createElement("span");
                wmTag.className = "job-tag subtle";
                wmTag.textContent = workMode;
                tags.appendChild(wmTag);

                card.appendChild(titleRow);
                card.appendChild(meta);
                card.appendChild(tags);

                container.appendChild(card);
            });
        }

        // ---------- Map + Beeswarm ----------
        async function loadMapAndBeeswarm() {
            try {
                // last 24 hours ONLY, lighter payload
                const res = await fetch(`${API_BASE}/api/beeswarm_jobs?limit=1200&days=1`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const jobs = await res.json();

                // update "today" metrics + job list before heavy viz
                updateTodaySnapshot(jobs);
                renderRecentJobs(jobs);

                initMapAndBeeswarm(jobs);
            } catch (err) {
                console.error("Error loading beeswarm_jobs", err);
            }
        }

        function initMapAndBeeswarm(jobs) {
            if (!jobs || jobs.length === 0) return;

            const clean = v => (v || "Unknown").toString().trim();

            const toInt = x => {
                if (x == null) return null;
                const m = x.toString().match(/\d+/);
                return m ? +m[0] : null;
            };

            const bucketTime = str => {
                const v = (str || "").toLowerCase();
                if (!v) return "Unknown";
                if (v.includes("hour")) return "Last 24h";
                if (v.includes("just")) return "Last 24h";
                if (v.includes("day")) return v.includes("1") ? "Last 24h" : "Past week";
                if (v.includes("week")) return "Past week";
                if (v.includes("month")) return "Past month";
                return "Older";
            };

            const degreeLevel = text => {
                const v = (text || "").toLowerCase();
                if (!v) return "Other";
                if (/(ph\.?d|doctor|doctoral)/.test(v)) return "PhD";
                if (/(master|m\.s\.|ms\b|m\.sc)/.test(v)) return "Master's";
                if (/(bachelor|b\.s\.|bs\b|ba\b|b\.a)/.test(v)) return "Bachelor's";
                if (/(associate|a\.s\.|aa\b)/.test(v)) return "Associate's";
                if (/high\s*school|ged/.test(v)) return "High School";
                if (/(enrolled|pursuing|currently)/.test(v)) return "Enrolled";
                return "Other";
            };

            function extractSkills(s) {
                if (!s) return [];
                return s.split(",")
                    .map(t => t.trim())
                    .filter(Boolean);
            }

            function companyBucket(name) {
                const s = (name || "").toLowerCase();
                if (!s) return "Other";
                if (/(google|meta|facebook|amazon|apple|microsoft|nvidia|netflix|adobe|salesforce|ibm|oracle)/.test(s)) {
                    return "Big Tech";
                }
                if (/(mckinsey|bcg|bain|deloitte|pwc|kpmg|ey|accenture|capgemini)/.test(s)) {
                    return "Consulting / Big 4";
                }
                if (/(goldman|morgan stanley|jpmorgan|jp morgan|bank of america|wells fargo|citigroup|ubs|barclays|blackrock|vanguard)/.test(s)) {
                    return "Finance";
                }
                return "Other";
            }

            const nodes = jobs.map((j, i) => {
                const loc = clean(j.location);
                const applicants = toInt(j.num_applicants);
                const timeBucket = bucketTime(j.time_posted); // use friendly "2 hours ago"
                const deg = degreeLevel(j.degree_qualifications);
                const skillsArr = extractSkills(j.skills || j.skills_desired);

                const fnRaw = j.job_function || j["Job Function"];
                const industryRaw = j.industry || j["Industries"];

                return {
                    id: j.job_id ?? i,
                    title: clean(j.job_title),
                    company: clean(j.company_name),
                    location: loc,
                    lat: j.latitude,
                    lng: j.longitude,
                    jobFunction: clean(fnRaw),
                    industry: clean(industryRaw),
                    timeBucket,
                    degreeLevel: deg,
                    workMode: clean(j.work_mode),
                    applicants,
                    skills: skillsArr,
                    jobLink: j.job_link || j.application_link,
                    companyBucket: companyBucket(j.company_name)
                };
            });

            // ---- Map aggregation ----
            const geoNodes = nodes.filter(d =>
                d.lat != null &&
                d.lng != null &&
                !Number.isNaN(d.lat) &&
                !Number.isNaN(d.lng)
            );

            if (mapInstance) {
                mapInstance.remove();
                mapInstance = null;
            }

            mapInstance = L.map("map").setView([38.0, -95.0], 4);
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: "© OpenStreetMap contributors"
            }).addTo(mapInstance);

            if (geoNodes.length > 0) {
                const byLocation = d3.group(
                    geoNodes,
                    d => `${d.location}|${d.lat}|${d.lng}`
                );

                const locArray = Array.from(byLocation, ([key, arr]) => {
                    const [loc, lat, lng] = key.split("|");
                    const latNum = +lat;
                    const lngNum = +lng;
                    const count = arr.length;
                    const avgApplicants = d3.mean(arr, d => d.applicants || 0) || 0;

                    let level = "unknown";
                    if (avgApplicants > 0 && avgApplicants < 60) level = "low";
                    else if (avgApplicants >= 60 && avgApplicants < 100) level = "medium";
                    else if (avgApplicants >= 100) level = "high";

                    return {
                        location: loc,
                        lat: latNum,
                        lng: lngNum,
                        jobs: arr,
                        jobCount: count,
                        avgApplicants,
                        level
                    };
                });

                const clusters = L.markerClusterGroup({
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: false
                });

                locArray.forEach(loc => {
                    const cls =
                        loc.level === "low" ? "marker-low" :
                            loc.level === "medium" ? "marker-medium" :
                                loc.level === "high" ? "marker-high" : "marker-unknown";

                    const icon = L.divIcon({
                        html: `<div class="custom-marker ${cls}" title="${loc.location}: ${loc.jobCount} jobs">${loc.jobCount}</div>`,
                        className: "",
                        iconSize: [30, 30],
                        iconAnchor: [15, 30]
                    });

                    const marker = L.marker([loc.lat, loc.lng], { icon });

                    let popupHTML = `<div style="font-size: 13px;">
              <b>${loc.location}</b><br>
              ${loc.jobCount} job${loc.jobCount === 1 ? "" : "s"}<br>
              Avg applicants: ${Math.round(loc.avgApplicants) || "N/A"}<br>
              <hr>`;

                    loc.jobs.slice(0, 20).forEach(job => {
                        popupHTML += `
                  <div style="margin-bottom: 8px;">
                    <strong>
                      ${job.jobLink
                                ? `<a href="${job.jobLink}" target="_blank" rel="noopener noreferrer">${job.title}</a>`
                                : job.title
                            }
                    </strong><br>
                    ${job.company} • ${job.jobFunction}<br>
                    <small>${job.timeBucket} • ${job.degreeLevel}</small>
                  </div>`;
                    });

                    popupHTML += `</div>`;
                    marker.bindPopup(popupHTML);
                    clusters.addLayer(marker);
                });

                mapInstance.addLayer(clusters);
            } else {
                console.warn("No geocoded jobs available for the map in this time window.");
            }

            // ---- Beeswarm ----
            const svg = d3.select("#beeswarm-svg");
            svg.selectAll("*").remove();

            const width = svg.node().clientWidth || 400;
            const height = svg.node().clientHeight || 450;
            const margin = { top: 10, right: 10, bottom: 10, left: 10 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            svg.attr("viewBox", `0 0 ${width} ${height}`);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const rScale = d3.scaleSqrt()
                .domain([0, d3.max(nodes, d => d.applicants || 0) || 1])
                .range([3, 10]);

            const DIM_INFO = {
                jobFunction: {
                    label: "Job Function",
                    groups: topK(nodes, d => d.jobFunction, 8)
                },
                industry: {
                    label: "Industry",
                    groups: topK(nodes, d => d.industry, 8)
                },
                companyBucket: {
                    label: "Companies",
                    groups: ["Big Tech", "Consulting / Big 4", "Finance", "Other"]
                },
                timeBucket: {
                    label: "Time Posted",
                    groups: ["Last 24h", "Past week", "Past month", "Older", "Unknown"]
                },
                degreeLevel: {
                    label: "Degree",
                    groups: ["Bachelor's", "Master's", "PhD", "Associate's", "Enrolled", "High School", "Other"]
                },
                skills: {
                    label: "Skills",
                    groups: topSkills(nodes, 12)
                }
            };

            function topK(arr, acc, k) {
                const m = d3.rollup(arr, v => v.length, acc);
                return Array.from(m, ([name]) => name)
                    .sort(d3.ascending)
                    .slice(0, k)
                    .concat("Other");
            }

            function topSkills(arr, k) {
                const counts = new Map();
                arr.forEach(d => {
                    d.skills.forEach(s => {
                        counts.set(s, (counts.get(s) || 0) + 1);
                    });
                });
                const sorted = Array.from(counts.entries())
                    .sort((a, b) => d3.descending(a[1], b[1]))
                    .map(d => d[0]);
                const top = sorted.slice(0, k);
                return top.concat("Other");
            }

            function groupValue(dim, d) {
                const info = DIM_INFO[dim];
                if (!info) return "Other";

                if (dim === "jobFunction") {
                    return info.groups.includes(d.jobFunction) ? d.jobFunction : "Other";
                }
                if (dim === "industry") {
                    return info.groups.includes(d.industry) ? d.industry : "Other";
                }
                if (dim === "companyBucket") {
                    return info.groups.includes(d.companyBucket) ? d.companyBucket : "Other";
                }
                if (dim === "timeBucket") {
                    return info.groups.includes(d.timeBucket) ? d.timeBucket : "Other";
                }
                if (dim === "degreeLevel") {
                    return info.groups.includes(d.degreeLevel) ? d.degreeLevel : "Other";
                }
                if (dim === "skills") {
                    const primarySkill = d.skills && d.skills.length ? d.skills[0] : "Other";
                    return info.groups.includes(primarySkill) ? primarySkill : "Other";
                }
                return "Other";
            }

            function makeCentroids(groups) {
                const n = groups.length;
                const cols = innerWidth > 520 ? 2 : 1;
                const rows = Math.ceil(n / cols);

                const xPad = 40;
                const yPad = 30;

                const xs = d3.scalePoint()
                    .domain(d3.range(cols))
                    .range([xPad, innerWidth - xPad])
                    .padding(0.5);

                const ys = d3.scalePoint()
                    .domain(d3.range(rows))
                    .range([yPad, innerHeight - yPad])
                    .padding(0.5);

                const map = new Map();
                groups.forEach((name, i) => {
                    const c = i % cols;
                    const r = Math.floor(i / cols);
                    map.set(name, { x: xs(c), y: ys(r) });
                });
                return map;
            }

            let currentDim = "jobFunction";
            let centroids = makeCentroids(DIM_INFO[currentDim].groups);

            const tooltip = d3.select("#bs-tip");

            const circles = g.append("g")
                .attr("class", "circles")
                .selectAll("circle")
                .data(nodes, d => d.id)
                .enter()
                .append("circle")
                .attr("r", d => rScale(d.applicants || 10))
                .attr("fill", d => {
                    if (d.timeBucket === "Last 24h") return "#22c55e";
                    if (d.timeBucket === "Past week") return "#0ea5e9";
                    return "#6b7280";
                })
                .attr("stroke", "rgba(0,0,0,0.4)")
                .attr("stroke-width", 0.5)
                .style("cursor", "pointer")
                .on("mouseenter", function (event, d) {
                    d3.select(this).attr("stroke-width", 1.5);
                    tooltip
                        .style("opacity", 1)
                        .html(`
                <strong>${d.title}</strong><br>
                ${d.company} — ${d.location}<br>
                <i>${d.jobFunction} • ${d.industry} • ${d.timeBucket} • ${d.degreeLevel}</i>
              `)
                        .style("left", (event.clientX + 12) + "px")
                        .style("top", (event.clientY + 12) + "px");
                })
                .on("mousemove", function (event) {
                    tooltip
                        .style("left", (event.clientX + 12) + "px")
                        .style("top", (event.clientY + 12) + "px");
                })
                .on("mouseleave", function () {
                    d3.select(this).attr("stroke-width", 0.5);
                    tooltip.style("opacity", 0);
                });

            const labelsLayer = g.append("g").attr("class", "labels");
            function renderGroupLabels() {
                const groups = DIM_INFO[currentDim].groups;
                const cent = centroids;

                const labels = labelsLayer.selectAll("text.group-label")
                    .data(groups, d => d);

                labels.enter()
                    .append("text")
                    .attr("class", "group-label")
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .merge(labels)
                    .attr("x", d => cent.get(d).x)
                    .attr("y", d => cent.get(d).y - 26)
                    .text(d => d);

                labels.exit().remove();
            }

            const simulation = d3.forceSimulation(nodes)
                .alpha(1)
                .velocityDecay(0.3)
                .force("x", d3.forceX(d => centroids.get(groupValue(currentDim, d)).x).strength(0.12))
                .force("y", d3.forceY(d => centroids.get(groupValue(currentDim, d)).y).strength(0.12))
                .force("collide", d3.forceCollide(d => rScale(d.applicants || 10) + 1.5))
                .on("tick", () => {
                    circles
                        .attr("cx", d => d.x = Math.max(8, Math.min(innerWidth - 8, d.x || innerWidth / 2)))
                        .attr("cy", d => d.y = Math.max(8, Math.min(innerHeight - 8, d.y || innerHeight / 2)));
                });

            renderGroupLabels();

            let activeChip = "All";
            const chipsWrap = d3.select("#bs-chips");

            function renderChips() {
                const groups = DIM_INFO[currentDim].groups;
                const cats = ["All", ...groups];

                const chips = chipsWrap.selectAll("div.chip")
                    .data(cats, d => d);

                chips.enter()
                    .append("div")
                    .attr("class", d => "chip" + (d === activeChip ? " active" : ""))
                    .text(d => d)
                    .on("click", (_, val) => {
                        activeChip = val;
                        chipsWrap.selectAll(".chip").classed("active", d => d === activeChip);
                        applyFilter();
                    });

                chips
                    .classed("active", d => d === activeChip)
                    .text(d => d);

                chips.exit().remove();
            }

            function applyFilter() {
                circles
                    .transition()
                    .duration(200)
                    .style("opacity", d => {
                        const gVal = groupValue(currentDim, d);
                        if (activeChip === "All") return 1;
                        return gVal === activeChip ? 1 : 0.15;
                    });
            }

            renderChips();
            applyFilter();

            d3.selectAll(".segmented button").on("click", function () {
                const dim = this.getAttribute("data-dim");
                if (dim === currentDim) return;

                d3.selectAll(".segmented button").classed("active", false);
                d3.select(this).classed("active", true);

                currentDim = dim;
                centroids = makeCentroids(DIM_INFO[currentDim].groups);
                simulation
                    .force("x", d3.forceX(d => centroids.get(groupValue(currentDim, d)).x).strength(0.12))
                    .force("y", d3.forceY(d => centroids.get(groupValue(currentDim, d)).y).strength(0.12));
                simulation.alpha(0.9).restart();

                activeChip = "All";
                renderChips();
                renderGroupLabels();
                applyFilter();
            });
        }

        // ---------- Kick everything off ----------
        loadOverview();
        loadDailyCounts();
        loadJobsByFunctionAll();
        loadJobsByFunction7d();
        loadWorkMode7d();
        loadHourlyCounts24h();
        loadMapAndBeeswarm();

        // Light endpoints every 3 minutes
        setInterval(() => {
            loadOverview();
            loadDailyCounts();
            loadJobsByFunctionAll();
            loadJobsByFunction7d();
            loadWorkMode7d();
            loadHourlyCounts24h();
        }, 3 * 60 * 1000);

        // Heavy map/beeswarm less frequently
        setInterval(() => {
            loadMapAndBeeswarm();
        }, 10 * 60 * 1000);
    </script>
</body>

</html>